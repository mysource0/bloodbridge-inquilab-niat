`admin-dashboard/code2.txt`

```
`code.txt`

```
`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`src/App.jsx`

```javascript
// src/App.jsx

import React, { useState } from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import LoginPage from './LoginPage.jsx';
import Dashboard from './Dashboard.jsx';
import theme from './theme.js';

/**
 * The main App component.
 * It acts as the root of the application, managing authentication state
 * and providing the global MUI theme.
 */
function App() {
  // State to track if the user is logged in. Default is false.
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  // Function to be passed to LoginPage to handle successful login
  const handleLogin = () => {
    setIsLoggedIn(true);
  };

  // Function to be passed to Dashboard to handle logout
  const handleLogout = () => {
    setIsLoggedIn(false);
  };

  return (
    // ThemeProvider applies the custom theme to all descendant components.
    // CssBaseline provides a consistent baseline style across browsers.
    <ThemeProvider theme={theme}>
      <CssBaseline />
      {/* Conditionally render Dashboard or LoginPage based on login state */}
      {isLoggedIn ? (
        <Dashboard onLogout={handleLogout} />
      ) : (
        <LoginPage onLogin={handleLogin} />
      )}
    </ThemeProvider>
  );
}

export default App;

```

`src/Dashboard.jsx`

```javascript
// src/Dashboard.jsx

import React, { useState, useEffect } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Grid, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress,
  Button,
} from "@mui/material";

import { Bloodtype, LocationCity, AddLink, Close } from "@mui/icons-material";

// âœ… Dummy API functions (replace with real API calls)
const fetchPendingPatients = async () =>
  Promise.resolve([
    { id: 1, name: "John Doe", blood_group: "A+", city: "Delhi" },
    { id: 2, name: "Jane Smith", blood_group: "O-", city: "Mumbai" },
  ]);

const fetchActiveEmergencies = async () =>
  Promise.resolve([
    { id: 3, patient_name: "Alex", blood_group: "B+", status: "Urgent" },
    { id: 4, patient_name: "Maria", blood_group: "AB-", status: "Open" },
  ]);

const Dashboard = ({ onLogout }) => {
  const [tabValue, setTabValue] = useState(0);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm")); // <600px
  const isTablet = useMediaQuery(theme.breakpoints.between("sm", "md")); // 600-900px
  const isLaptop = useMediaQuery(theme.breakpoints.between("md", "lg")); // 900-1200px

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      const apiCall = tabValue === 0 ? fetchPendingPatients : fetchActiveEmergencies;
      const result = await apiCall();
      setData(result);
      setLoading(false);
    };
    loadData();
  }, [tabValue]);

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // âœ… Card list for small & medium screens
  const renderCardList = () => (
    <Grid container spacing={2}>
      {data.map((item) => (
        <Grid item xs={12} sm={6} md={4} key={item.id}>
          <Card variant="outlined" sx={{ height: "100%" }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {tabValue === 0 ? item.name : item.patient_name}
              </Typography>
              <Stack direction="column" spacing={1}>
                <Chip
                  icon={<Bloodtype />}
                  label={`Blood Group: ${item.blood_group}`}
                  size="small"
                />
                {tabValue === 0 ? (
                  <Chip
                    icon={<LocationCity />}
                    label={`City: ${item.city}`}
                    size="small"
                  />
                ) : (
                  <Chip label={`Status: ${item.status}`} color="warning" size="small" />
                )}
              </Stack>
            </CardContent>
            <CardActions sx={{ justifyContent: "flex-end" }}>
              {tabValue === 0 ? (
                <Button variant="contained" size="small" startIcon={<AddLink />}>
                  Create Bridge
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="secondary"
                  size="small"
                  startIcon={<Close />}
                >
                  Close Request
                </Button>
              )}
            </CardActions>
          </Card>
        </Grid>
      ))}
    </Grid>
  );

  // âœ… Table for larger screens (Laptop & Desktop)
  const renderTable = () => (
    <TableContainer>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>{tabValue === 0 ? "Name" : "Patient Name"}</TableCell>
            <TableCell>Blood Group</TableCell>
            <TableCell>{tabValue === 0 ? "City" : "Status"}</TableCell>
            <TableCell align="right">Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {data.map((item) => (
            <TableRow hover key={item.id}>
              <TableCell>{tabValue === 0 ? item.name : item.patient_name}</TableCell>
              <TableCell>
                <Chip
                  label={item.blood_group}
                  color="primary"
                  variant="outlined"
                  size="small"
                />
              </TableCell>
              <TableCell>
                {tabValue === 0 ? (
                  item.city
                ) : (
                  <Chip label={item.status} color="warning" size="small" />
                )}
              </TableCell>
              <TableCell align="right">
                {tabValue === 0 ? (
                  <Button variant="contained" size="small" startIcon={<AddLink />}>
                    Create Bridge
                  </Button>
                ) : (
                  <Button
                    variant="contained"
                    color="secondary"
                    size="small"
                    startIcon={<Close />}
                  >
                    Close Request
                  </Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );

// inside src/Dashboard.jsx â€” modify the JSX return where Container is used:

  return (
    <Box
      sx={{
        flexGrow: 1,
        backgroundColor: theme.palette.background.default,
        minHeight: "100vh",
      }}
    >
      {/* AppBar stays full width of viewport */}
      <AppBar position="static" sx={{ boxShadow: 1 }}>
        <Toolbar sx={{ px: { xs: 2, md: 4 } }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            ðŸ©¸ BloodBridge AI
          </Typography>
          <Button color="inherit" onClick={onLogout}>
            Logout
          </Button>
        </Toolbar>
      </AppBar>

      {/* Make container span full width but keep inner content centered with a maxWidth */}
      <Container
        maxWidth={false}
        disableGutters
        sx={{
          px: { xs: 2, md: 4 },
          py: 4,
        }}
      >
        {/* center the page content while allowing it to be fluid on small screens */}
        <Box sx={{ width: "100%", maxWidth: 1100, mx: "auto" }}>
          <Typography variant="h4" gutterBottom>
            Admin Dashboard
          </Typography>

          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 3 }}>
              <Tabs value={tabValue} onChange={handleTabChange}>
                <Tab label="Pending Patients" />
                <Tab label="Active Emergencies" />
              </Tabs>
            </Box>

            {loading ? (
              <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
                <CircularProgress />
              </Box>
            ) : (
              // responsive decision: cards for small/tablet, table for larger screens
              (isMobile || isTablet) ? renderCardList() : renderTable()
            )}
          </Paper>
        </Box>
      </Container>
    </Box>
  );

};

export default Dashboard;

```

`src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`src/LoginPage.jsx`

```javascript
// src/LoginPage.jsx

import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert } from '@mui/material';

/**
 * The LoginPage component.
 * It displays a simple login form and validates the password.
 * On successful validation, it calls the onLogin prop function.
 */
const LoginPage = ({ onLogin }) => {
  // State to hold the password input value
  const [password, setPassword] = useState('');
  // State to hold any login error messages
  const [error, setError] = useState('');

  // Handles the form submission
  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent default form submission behavior

    // Simple validation: check if the password is "admin"
    if (password === 'admin') {
      setError(''); // Clear any previous errors
      onLogin(); // Call the parent component's login handler
    } else {
      // Set an error message for incorrect password
      setError('Incorrect password. Hint: try "admin"');
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h5">
          ðŸ©¸ BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {/* Display an error alert if the error state is not empty */}
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
          >
            Sign In
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;   

```

`src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

// It's good practice to have a minimal CSS reset or base styles.
// You can leave the default index.css or make it an empty file for now.
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

`src/mockApi.js`

```javascript
// src/mockApi.js

/**
 * This file acts as a fake backend API.
 * The functions here simulate network requests by returning a Promise
 * that resolves with mock data after a 500ms delay.
 */

// Mock data for the "Pending Patients" tab
const mockPendingPatients = [
  { "id": "p1", "name": "Aarav Sharma", "blood_group": "A+", "city": "Delhi" },
  { "id": "p2", "name": "Saanvi Gupta", "blood_group": "O-", "city": "Mumbai" },
  { "id": "p3", "name": "Vihaan Reddy", "blood_group": "B+", "city": "Bangalore" },
  { "id": "p4", "name": "Diya Singh", "blood_group": "AB-", "city": "Kolkata" }
];

// Mock data for the "Active Emergencies" tab
const mockActiveEmergencies = [
  { "id": "e1", "patient_name": "Isha Patel", "blood_group": "AB+", "status": "Searching" },
  { "id": "e2", "patient_name": "Rohan Kumar", "blood_group": "O+", "status": "Partially Fulfilled" },
  { "id": "e3", "patient_name": "Ananya Joshi", "blood_group": "A-", "status": "Critical" }
];

/**
 * Fetches a list of pending patients.
 * @returns {Promise<Array<Object>>} A promise that resolves to the patient list.
 */
export const fetchPendingPatients = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockPendingPatients);
    }, 500); // 500ms delay to simulate network latency
  });
};

/**
 * Fetches a list of active emergencies.
 * @returns {Promise<Array<Object>>} A promise that resolves to the emergencies list.
 */
export const fetchActiveEmergencies = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockActiveEmergencies);
    }, 500); // 500ms delay to simulate network latency
  });
};

```

`src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

```

`admin-dashboard/eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`admin-dashboard/index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`admin-dashboard/src/api/apiClient.js`

```javascript
// src/api/apiClient.js
import axios from 'axios';

const BASE = (import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001').replace(/\/$/, '');

const apiClient = axios.create({
  baseURL: BASE,
  headers: { 'Content-Type': 'application/json' },
  timeout: 20000,
});

// simple map to avoid spamming same error repeatedly
const loggedUrls = new Set();

apiClient.interceptors.request.use((config) => {
  const url = config.url || '';
  // attach token for everything except login/register
  if (!url.includes('/login') && !url.includes('/register')) {
    const token = localStorage.getItem('token');
    if (token && typeof token === 'string' && token.split('.').length === 3) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  return config;
});

apiClient.interceptors.response.use(
  (res) => res,
  (err) => {
    const out = {
      url: err.config?.url,
      status: err.response?.status,
      message: err.message,
      data: err.response?.data,
    };

    // Log each failing URL once to reduce noise
    if (!loggedUrls.has(out.url)) {
      loggedUrls.add(out.url);
      console.error('API request failed:', out);
    }

    const normalized = new Error(out.message || 'API error');
    normalized.url = out.url;
    normalized.status = out.status;
    normalized.data = out.data;
    return Promise.reject(normalized);
  }
);

export default apiClient;

```

`admin-dashboard/src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`admin-dashboard/src/App.jsx`

```javascript
// admin-dashboard/src/App.jsx
import React from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import { AuthProvider } from './context/AuthContext.jsx';
import { Routes, Route, Navigate } from 'react-router-dom'; // âœ… IMPORT ROUTER COMPONENTS
import theme from './theme.js';
import LoginPage from './pages/LoginPage.jsx';
import DashboardPage from './pages/Dashboard.jsx';
import { useAuth } from './hooks/useAuth.js';

/**
 * A protected route component. If the user is not logged in,
 * it redirects them to the login page.
 */
const ProtectedRoute = ({ children }) => {
  const { isLoggedIn } = useAuth();
  return isLoggedIn ? children : <Navigate to="/" />;
};

/**
 * The main App component, now with a proper routing structure.
 */
function App() {
  return (
    <AuthProvider>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Routes>
          <Route path="/" element={<LoginPage />} />
          
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute>
                <DashboardPage />
              </ProtectedRoute>
            } 
          />
        </Routes>
      </ThemeProvider>
    </AuthProvider>
  );
}

export default App;

```

`admin-dashboard/src/components/common/ConfirmationDialog.jsx`

```javascript
// src/components/common/ConfirmationDialog.jsx
import React, { useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import {
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from '@mui/material';

/**
 * Reusable confirmation dialog.
 * - Awaits async onConfirm handlers before closing.
 * - Disables buttons while processing to avoid duplicate calls.
 */
const ConfirmationDialog = ({ open, onClose, onConfirm, title, message, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
  const [processing, setProcessing] = useState(false);

  const handleConfirm = useCallback(async () => {
    if (processing) return;
    setProcessing(true);
    try {
      if (typeof onConfirm === 'function') {
        // Call handler and await if it returns a promise
        const result = onConfirm();
        if (result && typeof result.then === 'function') {
          await result;
        }
      }
    } catch (err) {
      // Log â€” parent can set error state if needed
      // Avoid swallowing errors silently in prod; you may surface this to UI
      // eslint-disable-next-line no-console
      console.error('ConfirmationDialog onConfirm error:', err);
    } finally {
      setProcessing(false);
      if (typeof onClose === 'function') onClose();
    }
  }, [onConfirm, onClose, processing]);

  return (
    <Dialog
      open={Boolean(open)}
      onClose={() => {
        if (!processing && typeof onClose === 'function') onClose();
      }}
      aria-labelledby="confirmation-dialog-title"
      aria-describedby="confirmation-dialog-description"
      fullWidth
      maxWidth="xs"
    >
      <DialogTitle id="confirmation-dialog-title">{title}</DialogTitle>
      <DialogContent>
        <DialogContentText id="confirmation-dialog-description">
          {message}
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={() => { if (!processing && typeof onClose === 'function') onClose(); }} disabled={processing}>
          {cancelText}
        </Button>

        <Button
          onClick={handleConfirm}
          color="primary"
          variant="contained"
          autoFocus
          disabled={processing}
        >
          {confirmText}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

ConfirmationDialog.propTypes = {
  open: PropTypes.bool,
  onClose: PropTypes.func,
  onConfirm: PropTypes.func,
  title: PropTypes.string,
  message: PropTypes.string,
  confirmText: PropTypes.string,
  cancelText: PropTypes.string,
};

ConfirmationDialog.defaultProps = {
  open: false,
  onClose: () => {},
  onConfirm: null,
  title: 'Confirm',
  message: '',
  confirmText: 'Confirm',
  cancelText: 'Cancel',
};

export default React.memo(ConfirmationDialog);

```

`admin-dashboard/src/components/dashboard/BloodGroupChart.jsx`

```javascript
// src/components/dashboard/BloodGroupChart.jsx
import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
} from 'recharts';
import { Box, Typography, useTheme } from '@mui/material';

/**
 * A responsive bar chart to display blood group distribution.
 * Expects data shape: [{ blood_group: 'A+', count: 10 }, ...]
 */
const BloodGroupChart = ({ data }) => {
  const theme = useTheme();

  // Defensive: normalize/sort data so chart is stable
  const prepared = useMemo(() => {
    if (!Array.isArray(data)) return [];
    // ensure numeric counts and stable ordering (by blood_group)
    return [...data]
      .map((d) => ({ blood_group: d.blood_group ?? 'Unknown', count: Number(d.count) || 0 }))
      .sort((a, b) => {
        // you can sort by count desc: return b.count - a.count;
        // here we sort by blood_group for predictable axis order
        return a.blood_group.localeCompare(b.blood_group);
      });
  }, [data]);

  if (!prepared || prepared.length === 0) {
    return (
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: 300 }}>
        <Typography color="text.secondary">No chart data available.</Typography>
      </Box>
    );
  }

  return (
    // aria-label helps screen readers understand this visual
    <Box role="img" aria-label="Donor distribution by blood group">
      <ResponsiveContainer width="100%" height={300}>
        <BarChart
          data={prepared}
          margin={{ top: 6, right: 16, left: -12, bottom: 6 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.divider} />
          <XAxis dataKey="blood_group" stroke={theme.palette.text.secondary} />
          <YAxis stroke={theme.palette.text.secondary} allowDecimals={false} />
          <Tooltip
            contentStyle={{
              backgroundColor: theme.palette.background.paper,
              borderColor: theme.palette.divider,
            }}
            formatter={(value) => [value, 'Donors']}
          />
          <Legend />
          <Bar dataKey="count" name="Total Donors" fill={theme.palette.primary.main} />
        </BarChart>
      </ResponsiveContainer>
    </Box>
  );
};

BloodGroupChart.propTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      blood_group: PropTypes.string,
      count: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    })
  ),
};

BloodGroupChart.defaultProps = {
  data: [],
};

export default React.memo(BloodGroupChart);

```

`admin-dashboard/src/components/dashboard/StatCard.jsx`

```javascript
// src/components/dashboard/StatCard.jsx
import React from "react";
import PropTypes from "prop-types";
import { Paper, Box, Typography, Avatar, useTheme } from "@mui/material";

/**
 * A reusable component to display a single dashboard statistic.
 *
 * Props:
 * - icon: React node shown inside the Avatar
 * - title: short label for the stat
 * - value: numeric or string value to display
 * - color: theme token or CSS color for Avatar background (e.g. "primary.main")
 */
const StatCard = ({ icon, title, value, color = "primary.main" }) => {
  const theme = useTheme();

  // Resolve theme token like "primary.main" to an actual color string
  const resolvedColor = (() => {
    if (!color) return undefined;
    // if color contains a dot, treat as theme token
    if (typeof color === "string" && color.includes(".")) {
      const [paletteKey, shade] = color.split(".");
      return theme.palette?.[paletteKey]?.[shade] ?? color;
    }
    return color;
  })();

  // Format numbers nicely (1000 -> 1,000)
  const formattedValue =
    typeof value === "number"
      ? new Intl.NumberFormat().format(value)
      : value ?? "â€”";

  return (
    <Paper
      elevation={3}
      sx={{
        p: 2,
        display: "flex",
        alignItems: "center",
        height: "100%",
      }}
      role="region"
      aria-label={`${title} stat`}
      title={`${title}: ${formattedValue}`}
    >
      <Avatar
        sx={{
          bgcolor: resolvedColor,
          width: 56,
          height: 56,
          mr: 2,
          color: (theme.palette.getContrastText
            ? theme.palette.getContrastText(resolvedColor)
            : "#fff"),
        }}
        aria-hidden="true"
      >
        {icon}
      </Avatar>

      <Box sx={{ minWidth: 0 }}>
        <Typography color="text.secondary" noWrap variant="caption">
          {title}
        </Typography>
        <Typography variant="h5" component="div" fontWeight="bold" noWrap>
          {formattedValue}
        </Typography>
      </Box>
    </Paper>
  );
};

StatCard.propTypes = {
  icon: PropTypes.node,
  title: PropTypes.string.isRequired,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  color: PropTypes.string,
};

StatCard.defaultProps = {
  icon: null,
  value: "0",
  color: "primary.main",
};

export default React.memo(StatCard);

```

`admin-dashboard/src/context/AuthContext.jsx`

```javascript
// src/context/AuthContext.jsx
import React, { createContext, useState } from 'react';

// 1. Create the context
// This object will be used by other components to access the auth state.
export const AuthContext = createContext(null);

// 2. Create the Provider component
// This component will wrap our application and provide the auth state.
export const AuthProvider = ({ children }) => {
  // Initialize the token state by reading from localStorage.
  // This ensures that the user remains logged in even after a page refresh.
  const [token, setToken] = useState(localStorage.getItem('token'));

  // The login function saves the token to both localStorage and the state.
  const login = (newToken) => {
    localStorage.setItem('token', newToken);
    setToken(newToken);
  };

  // The logout function removes the token from localStorage and the state.
  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
  };

  // 3. Define the value to be provided by the context
  // We derive `isLoggedIn` directly from the presence of a token.
  const value = {
    token,
    isLoggedIn: !!token,
    login,
    logout,
  };

  // 4. Return the provider with the value, wrapping any child components.
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

```

`admin-dashboard/src/hooks/useAuth.js`

```javascript
// src/hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext.jsx';

/**
 * A custom hook for accessing the AuthContext.
 * This simplifies the process in any component that needs auth data,
 * as we can just call `useAuth()` instead of `useContext(AuthContext)`.
 */
export const useAuth = () => {
  return useContext(AuthContext);
};

```

`admin-dashboard/src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`admin-dashboard/src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom'; // <-- 1. IMPORT THE ROUTER
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    {/* 2. WRAP YOUR APP WITH THE ROUTER */}
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

```

`admin-dashboard/src/pages/Dashboard.jsx`

```javascript
// admin-dashboard/src/pages/Dashboard.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress, Button, Alert,
  Badge, Grid, Snackbar
} from "@mui/material";
import {
  Bloodtype, LocationCity, AddLink, Close, Logout,
  PeopleAlt, Favorite, Healing, Warning,
  Dashboard as DashboardIcon, Inbox as InboxIcon,
  People as PeopleIcon, Emergency as EmergencyIcon,
  Hub as HubIcon, ShowChart as ShowChartIcon,
  CheckCircleOutline as CheckCircleOutlineIcon,
  NotificationImportant as EscalationIcon,
  AddCircleOutline as AddCircleOutlineIcon
} from "@mui/icons-material";
import { createClient } from '@supabase/supabase-js';

import { useAuth } from "../hooks/useAuth.js";
import apiClient from "../api/apiClient.js";
import StatCard from "../components/dashboard/StatCard.jsx";
import BloodGroupChart from "../components/dashboard/BloodGroupChart.jsx";
import ConfirmationDialog from "../components/common/ConfirmationDialog.jsx";

// --- INITIALIZE SUPABASE CLIENT ---
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseAnonKey);

const normalizeList = (res) => {
  if (!res) return [];
  if (Array.isArray(res)) return res;
  const d = res.data;
  if (Array.isArray(d)) return d;
  if (d && Array.isArray(d.data)) return d.data;
  return [];
};

const TabPanel = ({ children, value, index, ...other }) => (
  <div role="tabpanel" hidden={value !== index} {...other}>
    {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
  </div>
);

const getDueDateInfo = (dueDate) => {
  if (!dueDate) return { text: 'N/A', color: 'text.secondary', days: Infinity };
  const today = new Date();
  const nextDate = new Date(dueDate);
  today.setHours(0, 0, 0, 0);
  nextDate.setHours(0, 0, 0, 0);
  const diffTime = nextDate - today;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return { text: `OVERDUE by ${Math.abs(diffDays)} days`, color: 'error.main', days: diffDays };
  if (diffDays === 0) return { text: 'DUE TODAY', color: 'error.main', days: diffDays };
  if (diffDays <= 7) return { text: `Due in ${diffDays} days`, color: 'warning.main', days: diffDays };
  return { text: `Due in ${diffDays} days`, color: 'text.primary', days: diffDays };
};

const DashboardPage = () => {
  const { logout } = useAuth();
  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("md"));
  const [currentTab, setCurrentTab] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [snackbar, setSnackbar] = useState({ open: false, message: '' });
  const [dialogConfig, setDialogConfig] = useState({ open: false, title: '', message: '', onConfirm: () => {} });

  const [stats, setStats] = useState({});
  const [bloodGroupData, setBloodGroupData] = useState([]);
  const [inboxMessages, setInboxMessages] = useState([]);
  const [pendingPatients, setPendingPatients] = useState([]);
  const [monitoredPatients, setMonitoredPatients] = useState([]);
  const [emergencies, setEmergencies] = useState([]);
  const [bridges, setBridges] = useState([]);
  const [leaderboard, setLeaderboard] = useState([]);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      const [
        statsRes, 
        bloodGroupRes, 
        patientsRes, 
        emergenciesRes, 
        bridgesRes, 
        inboxRes,
        leaderboardRes
      ] = await Promise.all([
        apiClient.get('/api/admin/stats'),
        apiClient.get('/api/admin/stats/blood-groups'),
        apiClient.get('/api/admin/patients'),
        apiClient.get('/api/admin/emergencies'),
        apiClient.get('/api/admin/bridges'),
        apiClient.get('/api/admin/inbox'),
        apiClient.get('/api/admin/leaderboard')
      ]);

      setStats(statsRes.data || {});
      setBloodGroupData(bloodGroupRes.data || []);
      setEmergencies(normalizeList(emergenciesRes));
      setBridges(normalizeList(bridgesRes));
      setInboxMessages(normalizeList(inboxRes));
      setLeaderboard(normalizeList(leaderboardRes));

      const allPatients = normalizeList(patientsRes);
      const PENDING_STATUSES = ['pending', 'pending_opt_in', 'pending_details', 'pending_verification'];
      setPendingPatients(allPatients.filter(p => PENDING_STATUSES.includes(p.status)));
      
      const bridged = allPatients.filter(p => p.status === 'bridged');
      bridged.sort((a, b) => getDueDateInfo(a.next_due_date).days - getDueDateInfo(b.next_due_date).days);
      setMonitoredPatients(bridged);
    } catch (err) {
      setError('Failed to fetch data. Your session may have expired.');
      if (err.response && err.response.status === 401) logout();
    } finally {
      setLoading(false);
    }
  }, [logout]);

  useEffect(() => {
    fetchData();
    if (supabaseUrl && supabaseAnonKey) {
      const channel = supabase.channel('public-db-changes')
        .on('postgres_changes', { event: '*', schema: 'public' }, () => {
          console.log('Real-time change detected, refetching data...');
          fetchData();
        })
        .subscribe();
      
      return () => { supabase.removeChannel(channel); };
    }
  }, [fetchData]);

  const handleApiAction = async (action, successMessage) => {
    try {
      const response = await action();
      setSnackbar({ open: true, message: response.data.message || successMessage });
      fetchData();
    } catch (err) {
      setSnackbar({ open: true, message: err.response?.data?.error || 'Action failed!' });
    }
    setDialogConfig({ ...dialogConfig, open: false });
  };

  const confirmAction = (title, message, action, successMessage) => {
    setDialogConfig({ open: true, title, message, onConfirm: () => handleApiAction(action, successMessage) });
  };

  const renderLeaderboard = () => {
    if (loading && leaderboard.length === 0) {
      return <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}><CircularProgress /></Box>;
    }
    if (!leaderboard || leaderboard.length === 0) {
      return <Typography sx={{ p: 3, textAlign: 'center', height: '100%' }}>No donor data for leaderboard.</Typography>;
    }
    return (
      <TableContainer>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>Rank</TableCell>
              <TableCell>Name</TableCell>
              <TableCell align="right">Points</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {leaderboard.map((donor, index) => (
              <TableRow key={index}>
                <TableCell>{index + 1}</TableCell>
                <TableCell>{donor.name}</TableCell>
                <TableCell align="right">{donor.gamification_points}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  const renderDuePatientsAlert = () => {
    const duePatients = monitoredPatients.filter(p => getDueDateInfo(p.next_due_date).days <= 7);
    
    if (duePatients.length === 0) return null;
    
    return (
      <Paper elevation={3} sx={{ p: { xs: 2, md: 3 }, mb: 4, border: 2, borderColor: 'error.main' }}>
        <Typography variant="h6" color="error.main" gutterBottom>
          Action Required: Patients Due for Transfusion
        </Typography>
        <TableContainer>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Name</TableCell>
                <TableCell>Due Date</TableCell>
                <TableCell>Status</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {duePatients.map((p) => {
                const dueInfo = getDueDateInfo(p.next_due_date);
                return (
                  <TableRow key={p.id} hover>
                    <TableCell>{p.name}</TableCell>
                    <TableCell>{p.next_due_date ? new Date(p.next_due_date).toLocaleDateString() : 'N/A'}</TableCell>
                    <TableCell sx={{ color: dueInfo.color }}>{dueInfo.text}</TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    );
  };

  const renderTabContent = () => {
    switch (currentTab) {
      case 0: // Analytics
        return (
          <Grid container spacing={3} sx={{ mt: 1 }}>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<PeopleIcon />} title="Total Donors" value={stats.total_donors} />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Favorite />} title="Active & Eligible" value={stats.active_donors} color="success.main" />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Warning />} title="Patients Due Soon" value={stats.patients_at_risk} color="warning.main" />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Healing />} title="Pending Patients" value={stats.pending_patients} color="info.main" />
            </Grid>
            
            <Grid item sx={{ width: { xs: '100%', lg: '66%' } }}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>Donor Blood Groups</Typography>
                <Box sx={{ height: 320 }}>
                  <BloodGroupChart data={bloodGroupData} />
                </Box>
              </Paper>
            </Grid>
            <Grid item sx={{ width: { xs: '100%', lg: '34%' } }}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>Top Donors Leaderboard</Typography>
                {renderLeaderboard()}
              </Paper>
            </Grid>
          </Grid>
        );
      
      case 1: // Inbox
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>User Phone</TableCell>
                  <TableCell>Message</TableCell>
                  <TableCell>Reason</TableCell>
                  <TableCell align="right">Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {inboxMessages.map((msg) => (
                  <TableRow key={msg.id}>
                    <TableCell>{msg.user_phone}</TableCell>
                    <TableCell>{msg.user_message}</TableCell>
                    <TableCell><Chip label={msg.reason} color="warning" size="small" /></TableCell>
                    <TableCell align="right">
                      <Button 
                        onClick={() => confirmAction(
                          'Confirm Resolution', 
                          `Mark message from ${msg.user_phone} as resolved?`, 
                          () => apiClient.post(`/api/admin/inbox/${msg.id}/resolve`), 
                          'Message Resolved!'
                        )} 
                        startIcon={<CheckCircleOutlineIcon />}
                      >
                        Resolve
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 2: // Pending Patients
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Name</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {pendingPatients.map((p) => (
                  <TableRow key={p.id}>
                    <TableCell>{p.name}</TableCell>
                    <TableCell><Chip label={p.status} size="small" /></TableCell>
                    <TableCell>
                      <Button 
                        onClick={() => confirmAction(
                          'Confirm Bridge Creation', 
                          `Create a bridge for ${p.name}?`, 
                          () => apiClient.post(`/api/admin/patients/${p.id}/create-bridge`), 
                          'Bridge Created!'
                        )} 
                        startIcon={<AddCircleOutlineIcon />}
                      >
                        Create Bridge
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 3: // Patient Monitor
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Patient Name</TableCell>
                  <TableCell>Next Transfusion</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {monitoredPatients.map((p) => { 
                  const ddi = getDueDateInfo(p.next_due_date); 
                  return (
                    <TableRow key={p.id} sx={{ backgroundColor: ddi.days < 0 ? 'rgba(255, 0, 0, 0.1)' : 'transparent' }}>
                      <TableCell>{p.name}</TableCell>
                      <TableCell sx={{ color: ddi.color }}>{ddi.text}</TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 4: // Active Emergencies
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Patient</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {emergencies.map((req) => (
                  <TableRow key={req.id}>
                    <TableCell>{req.patient_name}</TableCell>
                    <TableCell>{req.status}</TableCell>
                    <TableCell>
                      <Stack direction="row" spacing={1}>
                        <Button 
                          size="small" 
                          onClick={() => confirmAction(
                            'Confirm Closure', 
                            `Close request for ${req.patient_name}?`, 
                            () => apiClient.post(`/api/admin/emergencies/${req.id}/close`), 
                            'Request Closed!'
                          )} 
                          startIcon={<Close />}
                        >
                          Close
                        </Button>
                        <Button 
                          size="small" 
                          color="warning" 
                          onClick={() => confirmAction(
                            'Confirm Escalation', 
                            `Escalate request for ${req.patient_name}?`, 
                            () => apiClient.post(`/api/admin/emergencies/${req.id}/escalate`), 
                            'Escalation Initiated!'
                          )} 
                          startIcon={<EscalationIcon />}
                        >
                          Escalate
                        </Button>
                      </Stack>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 5: // Bridge Monitor
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Bridge Name</TableCell>
                  <TableCell>Patient</TableCell>
                  <TableCell>Members</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {bridges.map((b) => (
                  <TableRow key={b.id}>
                    <TableCell>{b.name}</TableCell>
                    <TableCell>{b.patient_name}</TableCell>
                    <TableCell>{b.member_count}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      default:
        return <div>Select a tab</div>;
    }
  };

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', bgcolor: 'background.default' }}>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>ðŸ©¸ BloodBridge AI Dashboard</Typography>
          <Button color="inherit" onClick={logout} startIcon={<Logout />}>Logout</Button>
        </Toolbar>
      </AppBar>

      <Container maxWidth="xl" sx={{ mt: 2, mb: 4, flexGrow: 1, overflowY: 'auto' }}>
        {renderDuePatientsAlert()}
        
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <Paper sx={{ p: 2 }}>
          <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
            <Tabs 
              value={currentTab} 
              onChange={(e, val) => setCurrentTab(val)} 
              variant="scrollable" 
              scrollButtons="auto"
            >
              <Tab icon={<ShowChartIcon />} label="Analytics" />
              <Tab icon={<InboxIcon />} label={
                <Badge badgeContent={inboxMessages.length} color="error">
                  Inbox
                </Badge>
              } />
              <Tab icon={<PeopleIcon />} label={
                <Badge badgeContent={pendingPatients.length} color="primary">
                  Pending Patients
                </Badge>
              } />
              <Tab icon={<PeopleIcon />} label="Patient Monitor" />
              <Tab icon={<EmergencyIcon />} label="Active Emergencies" />
              <Tab icon={<HubIcon />} label="Bridge Monitor" />
            </Tabs>
          </Box>

          {loading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
              <CircularProgress />
            </Box>
          ) : (
            renderTabContent()
          )}
        </Paper>
      </Container>

      <ConfirmationDialog 
        {...dialogConfig} 
        onClose={() => setDialogConfig({ ...dialogConfig, open: false })} 
      />
      
      <Snackbar 
        open={snackbar.open} 
        autoHideDuration={6000} 
        onClose={() => setSnackbar({ ...snackbar, open: false })} 
        message={snackbar.message} 
      />
    </Box>
  );
};

export default DashboardPage;

```

`admin-dashboard/src/pages/LoginPage.jsx`

```javascript
// admin-dashboard/src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth.js';
import apiClient from '../api/apiClient.js';

const LoginPage = () => {
  const { login } = useAuth();
  const navigate = useNavigate();

  // --- MODIFICATION: Hardcode the phone number for the demo user ---
  // We no longer need a state for the phone number.
  const phone = '+918000000000';
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleLogin = async (event) => {
    event.preventDefault();
    setError('');
    
    // Simple password validation
    if (!password) {
        setError('Password is required.');
        return;
    }

    setLoading(true);
    try {
      // The component now sends the hardcoded phone number and the entered password.
      console.log('Attempting login with:', { phone, password });
      const response = await apiClient.post('/api/admin/login', { phone, password });

      if (response.data?.token) {
        console.log('Login successful, token:', response.data.token);
        // Using localStorage to persist the token across browser sessions.
        localStorage.setItem('token', response.data.token);
        login(response.data.token);
        navigate('/dashboard');
      } else {
        // This case is unlikely if the backend is structured correctly, but good to have.
        setError('Login failed: No token received from server.');
      }
    } catch (err) {
      console.error('Login error:', {
        message: err.message,
        status: err.response?.status,
        data: err.response?.data,
      });

      // Provide more specific feedback to the user.
      if (err.response?.status === 401) {
        setError('Invalid password. Hint: try "admin123"');
      } else if (err.code === 'ECONNABORTED' || !err.response) {
        setError('Cannot connect to the server. Please ensure it is running.');
      } else {
        setError(err.response?.data?.message || 'An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box sx={{ mt: 8, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Typography component="h1" variant="h5">
          ðŸ©¸ BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleLogin} sx={{ mt: 3, width: '100%' }}>
          {/* --- MODIFICATION: The phone number input field has been removed --- */}
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            disabled={loading}
            sx={{ mt: 3, mb: 2 }}
          >
            {loading ? <CircularProgress size={24} color="inherit" /> : 'Sign In'}
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;

```

`admin-dashboard/src/pages/RegisterPage.jsx`

```javascript


```

`admin-dashboard/src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`admin-dashboard/vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

`backend/.env`

```
# ----------------------------------
# SERVER CONFIGURATION
# ----------------------------------
PORT=3001

# ----------------------------------
# SECURITY
# ----------------------------------
# Generate a new random string from https://www.uuidgenerator.net/ and paste it here
JWT_SECRET="eb4db4a414678902613083784a04ec9de45570856d8ced1dbe6fdd4a545ff715"

# ----------------------------------
# DATABASE (CONNECTION POOLER)
# ----------------------------------
# Replace the ENTIRE line below with your Connection Pooler URI from Supabase
DATABASE_URL="postgresql://postgres.psussvygzgzkkwdjqbwp:asdfusahdfuu3842r7gdsfh@aws-1-ap-southeast-1.pooler.supabase.com:6543/postgres"

# ----------------------------------
# THIRD-PARTY APIs
# ----------------------------------
# Paste your Gemini API key from Google AI Studio
GEMINI_API_KEY="AIzaSyBrkoxm2wP2Wd__AGVspY9bP9G_DwZxGOg"

# For the local Python service
ML_SERVICE_URL="http://localhost:8000"

# ----------------------------------
# WHATSAPP (FROM YOUR META APP)
# ----------------------------------
# Paste your own credentials from your Meta for Developers App
WHATSAPP_TOKEN="EAAY5EGe8MHkBPSNKbGVvTgOUrnZBZAGOP6v7b8rz7M9iVoQsV4AicoQKInVE6zu7Ou5dSXaWhHvxJJroXSaknHBt3Jtsqd4dw3hOZABmPCVDRSPT3cJJML1U3CEBlXfgZB7aF2NG6zoY1HFqCKFYgEPEyQaFo2LacMRyWqV1KiEIWgJbaYRXsiFfYsZCwuEC7ALLGkBEZB1LA1aZB96obPX23B4JYBOvCLcGmQZBYUa5KCkZD"
WHATSAPP_PHONE_NUMBER_ID="729824143554882"
WHATSAPP_APP_SECRET="e94bd0c1a5619ee68b105222b0185dc6"
WHATSAPP_VERIFY_TOKEN="inquilab_bloodai-123-2025-hackathon"

# ----------------------------------
# DEMO & ADMIN
# ----------------------------------
ADMIN_DEMO_PHONE="+918000000000"
DEMO_VERIFIED_PHONE_NUMBERS=""


```

`backend/server.js`

```javascript
// backend/server.js

// Import required dependencies
import express from 'express'; // Express framework for building the server
import cors from 'cors'; // Middleware for enabling CORS
import morgan from 'morgan'; // Middleware for request logging
import config from './src/config/config.js'; // Configuration settings
import adminRoutes from './src/routes/adminRoutes.js'; // Admin dashboard routes
import { verifyWebhook } from './src/middleware/verifyWebhook.js'; // Webhook signature verification
import webhookController from './src/controllers/webhookController.js'; // Webhook handling controller
import BridgeCoordinationService from './src/services/bridgeCoordinationService.js';

// --- PHASE 1: PREDICTIVE ENGAGEMENT ---
import cron from 'node-cron'; // Import the cron scheduler library
import EngagementService from './src/services/engagementService.js'; // Import our new engagement service
// --- END PHASE 1 ---

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3001; // Use environment PORT or default to 3001

// Middleware setup
app.use(cors()); // Enable CORS for all routes
app.use(morgan('tiny')); // Log HTTP requests in 'tiny' format

// API and Health Routes
app.get('/health', (req, res) => {
  // Health check endpoint to verify server status
  res.status(200).json({ status: 'healthy', now: new Date().toISOString() });
});

// Admin routes with JSON body parser
app.use('/api/admin', express.json({ limit: '1mb' }), adminRoutes);

// Webhook Routes
app.get('/webhook', webhookController.verifyToken); // Handle Meta webhook verification (GET)

app.post(
  '/webhook',
  express.json({
    verify: (req, res, buf) => {
req.rawBody = buf.toString();     }
  }),
  verifyWebhook, // This middleware will now use req.rawBody
  webhookController.handleMessage // This controller will use the parsed req.body
);

// Global Error Handling
app.use((err, req, res, next) => {
  // Handle errors from middleware or routes
  console.error('[ERROR HANDLER]', err.stack);
  res.status(500).json({ message: 'An internal server error occurred.' });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason) => {
  console.error('Unhandled Rejection:', reason);
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
});


// --- PHASE 1: PREDICTIVE ENGAGEMENT SCHEDULER ---
// This task is scheduled to run at 9:00 AM every day in the Asia/Kolkata timezone.
// It will automatically find donors who are now eligible to donate again and send them a reminder.
console.log('ðŸ•’ Cron job for eligibility reminders scheduled to run every day at 9:00 AM.');
cron.schedule('0 9 * * *', () => {
  console.log('â° It is 9:00 AM. Triggering the eligibility reminder cron job...');
  // We create a new instance to ensure it's a fresh run
  const engagementService = new EngagementService();
  engagementService.sendEligibilityReminders();
}, {
  scheduled: true,
  timezone: "Asia/Kolkata" // IMPORTANT: Set to your target timezone
});

console.log('ðŸ•’ Cron job for automatic bridge requests scheduled to run every day at 8:00 AM.');
cron.schedule('0 8 * * *', () => {
  console.log('â° It is 8:00 AM. Triggering automatic bridge requests...');
  const bridgeService = new BridgeCoordinationService();
  bridgeService.triggerAutomaticBridgeRequests();
}, {
  scheduled: true,
  timezone: "Asia/Kolkata"
});

// '0 10 * * 0' means at minute 0, hour 10, on day-of-week 0 (Sunday).
console.log('ðŸ•’ Cron job for inactive donor nudges scheduled to run every Sunday at 10:00 AM.');
cron.schedule('0 10 * * 0', () => {
    console.log('â° It is Sunday 10:00 AM. Triggering inactive donor nudge...');
    const engagementService = new EngagementService();
    engagementService.sendInactiveDonorNudges();
}, {
    scheduled: true,
    timezone: "Asia/Kolkata"
});
// --- END PHASE 1 ---


// Start the server
app.listen(PORT, () => {
  console.log(`âœ… BloodBridge AI backend is running on port ${PORT}`);
});

```

`backend/src/config/config.js`

```javascript
// backend/src/config/config.js
import 'dotenv/config'; // Loads variables from .env into process.env

// This object maps environment variables to a clean, accessible config object.
const config = {
    port: process.env.PORT,
    jwtSecret: process.env.JWT_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    geminiApiKey: process.env.GEMINI_API_KEY,
    mlServiceUrl: process.env.ML_SERVICE_URL,
    whatsappToken: process.env.WHATSAPP_TOKEN,
    whatsappPhoneNumberId: process.env.WHATSAPP_PHONE_NUMBER_ID,
    whatsappAppSecret: process.env.WHATSAPP_APP_SECRET,
    whatsappVerifyToken: process.env.WHATSAPP_VERIFY_TOKEN,
    adminDemoPhone: process.env.ADMIN_DEMO_PHONE,
    demoVerifiedPhoneNumbers: process.env.DEMO_VERIFIED_PHONE_NUMBERS
};

// This validation step ensures the application fails fast if critical secrets are missing.
// It's a crucial security and stability feature.
const requiredConfig = ['port', 'jwtSecret', 'databaseUrl'];
const missingConfig = requiredConfig.filter(key => !config[key]);

if (missingConfig.length > 0) {
    console.error(`ðŸ”´ FATAL ERROR: Missing required environment variables: ${missingConfig.join(', ')}`);
    // Exit the application with an error code.
    process.exit(1);
}

export default config;

```

`backend/src/config/db.js`

```javascript
// backend/src/config/db.js
import { Pool } from 'pg';
import config from './config.js';

/**
 * Creates a new connection pool.
 * The pool manages multiple client connections to the database,
 * reusing them to improve performance and stability.
 */
const pool = new Pool({
  connectionString: config.databaseUrl,
});

/**
 * A helper function to execute a simple query.
 * @param {string} text - The SQL query string.
 * @param {Array} params - The parameters to pass to the query.
 * @returns {Promise<QueryResult>} The result from the database.
 */
const query = (text, params) => pool.query(text, params);

// We export the entire pool so we can use it for transactions later,
// and the query function for convenience.
const db = {
  query,
  pool,
};

export default db;

```

`backend/src/controllers/adminController.js`

```javascript
// backend/src/controllers/adminController.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import db from '../config/db.js';
import bridgeService from '../services/bridgeService.js';
import bridgeCoordinationService from '../services/bridgeCoordinationService.js'; 
import emergencyService from '../services/emergencyService.js';

/**
 * Admin Login
 */
export const login = async (req, res) => {
  const { phone, password } = req.body;
  if (!phone || !password) {
    return res.status(400).json({ message: 'Phone and password are required' });
  }
  try {
    // Demo admin login (for prototype)
    if (phone === config.adminDemoPhone && password === 'admin123') {
      const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
      console.log(`Login successful for demo admin: ${phone}`);
      return res.json({ token });
    }
    // In a real app, you would have hashed password validation here
    const { rows } = await db.query(
      'SELECT * FROM users WHERE phone = $1 AND role = $2',
      [phone, 'Admin']
    );
    if (rows.length === 0 || rows[0].password !== password) {
      console.warn('Login failed for phone:', phone);
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
    console.log(`Login successful for user: ${phone}`);
    return res.json({ token });

  } catch (err) {
    console.error('Login error:', { error: err.message, phone });
    return res.status(500).json({ message: 'Server error during login' });
  }
};

/**
 * Create a Blood Bridge for a Patient
 */
export const createBridgeForPatient = async (req, res) => {
  const { patientId } = req.params;
  try {
    const { rows: [patient] } = await db.query(
      'SELECT * FROM patients WHERE id = $1',
      [patientId]
    );

    if (!patient) {
      return res.status(404).json({ message: 'Patient not found' });
    }
    if (patient.status === 'bridged') {
      return res.status(400).json({ message: 'Patient already has a bridge.' });
    }

    const { rows: [bridge] } = await db.query(
      'INSERT INTO blood_bridges (patient_id, name, blood_group, city) VALUES ($1, $2, $3, $4) RETURNING id',
      [patient.id, `${patient.name}'s Bridge`, patient.blood_group, patient.city]
    );

    const result = await bridgeService.populateNewBridge(
      bridge.id,
      patient.city,
      patient.blood_group,
      patient.pincode
    );

    await db.query(
      "UPDATE patients SET status = 'bridged' WHERE id = $1",
      [patientId]
    );
    console.log(`ADMIN ACTION: Created and populated Bridge ${bridge.id} with ${result.count} members.`);
    res.json({
      success: true,
      message: `Blood Bridge created and populated with ${result.count} top donors.`
    });
  } catch (error) {
    console.error('Error creating bridge for patient:', error);
    await db.query( "UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    res.status(500).json({ error: 'Failed to create and populate bridge.' });
  }
};

/**
 * Close Emergency Request
 */
export const closeEmergency = async (req, res) => {
  const { requestId } = req.params;
  try {
    const { rowCount } = await db.query(
      "UPDATE emergency_requests SET status = 'closed' WHERE id = $1 AND status = 'active'",
      [requestId]
    );
    if (rowCount === 0) {
      return res.status(404).json({ message: "Active request not found or already closed."})
    }
    console.log(`ADMIN ACTION: Closed emergency request ${requestId}`);
    res.json({ success: true, message: 'Request successfully closed.' });
  } catch (error) {
    console.error(`Error closing emergency ${requestId}:`, error);
    res.status(500).json({ error: 'Failed to close request.' });
  }
};

/**
 * Triggers a transfusion request for a patient in a Blood Bridge.requestBridgeTransfusion
 */
export const requestBridgeTransfusion = async (req, res) => {
  const { bridgeId } = req.params;
  try {
    // Use the imported instance directly
    const result = await bridgeCoordinationService.requestTransfusion(bridgeId);
  // --- END OF FIX ---
    console.log(`ADMIN ACTION: Triggered transfusion request for bridge ${bridgeId}`);
    res.json(result);
  } catch (error) {
    console.error(`Error requesting bridge transfusion for ${bridgeId}:`, error);
    res.status(500).json({ error: error.message || 'Failed to send bridge request.' });
  }
};

/**
 * Fetches the four main statistics for the StatCards on the dashboard.
 */
export const getDashboardStats = async (req, res) => {
  try {
    const [
      { rows: [totalDonors] },
      { rows: [activeDonors] },
      { rows: [pendingPatients] },
      { rows: [atRisk] }
    ] = await Promise.all([
      db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor'"),
      db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor' AND availability_status = 'available'"),
      db.query("SELECT COUNT(*) as count FROM patients WHERE status = 'pending_verification'"),
      db.query("SELECT COUNT(*) as count FROM emergency_requests WHERE status = 'active'")
    ]);
    
    res.json({
      total_donors: parseInt(totalDonors.count, 10),
      active_donors: parseInt(activeDonors.count, 10),
      pending_patients: parseInt(pendingPatients.count, 10),
      patients_at_risk: parseInt(atRisk.count, 10),
    });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ error: 'Failed to fetch dashboard stats.' });
  }
};

/**
 * Fetches the count of donors for each blood group for the chart.
 */
export const getBloodGroupStats = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT blood_group, COUNT(*) as count 
       FROM users 
       WHERE user_type = 'donor' AND blood_group IS NOT NULL AND blood_group != 'Unknown'
       GROUP BY blood_group 
       ORDER BY blood_group`
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching blood group stats:', error);
    res.status(500).json({ error: 'Failed to fetch blood group stats.' });
  }
};

/**
 * Fetches patients with 'pending_verification' status for the Patients tab.
 */

export const getPatients = async (req, res) => {
  try {
    // --- THIS IS THE CORRECTED QUERY ---
    // Instead of a risky subquery, we use a LEFT JOIN. This is safer and more efficient.
    // It correctly handles the case where a patient has no bridge yet (member_count will be 0).
    const query = `
      SELECT 
        p.id, p.name, p.phone, p.blood_group, p.city, p.status, p.condition,
        p.last_transfusion_date, p.frequency_in_days,
        p.last_transfusion_date + (p.frequency_in_days || ' days')::interval AS next_due_date,
        COUNT(bm.id) as bridge_member_count
      FROM 
        patients p
      LEFT JOIN 
        blood_bridges bb ON p.id = bb.patient_id
      LEFT JOIN 
        bridge_members bm ON bb.id = bm.bridge_id
      GROUP BY
        p.id
      ORDER BY 
        p.created_at DESC
    `;
    // --- END OF CORRECTION ---
    
    const { rows } = await db.query(query);
    res.json(rows);
  } catch (error) {
    console.error('Error fetching patients:', error);
    res.status(500).json({ error: 'Failed to fetch patients.' });
  }
};

/**
 * Fetches all 'active' emergencies for the Emergencies tab.
 */
export const getActiveEmergencies = async (req, res) => {
  try {
    const { rows } = await db.query(
      "SELECT id, patient_name, blood_group, status, city FROM emergency_requests WHERE status = 'active' ORDER BY created_at DESC"
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching active emergencies:', error);
    res.status(500).json({ error: 'Failed to fetch active emergencies.' });
  }
};

/**
 * Fetches all created Blood Bridges for the Blood Bridges tab.
 */
export const getBloodBridges = async (req, res) => {
    try {
        const { rows } = await db.query(
            `SELECT 
                bb.id, 
                bb.name, -- Select the bridge's name
                p.name as patient_name,
                COUNT(bm.id) as member_count -- Count the members in each bridge
             FROM 
                blood_bridges bb
             JOIN 
                patients p ON bb.patient_id = p.id
             LEFT JOIN -- Use LEFT JOIN in case a bridge has 0 members
                bridge_members bm ON bb.id = bm.bridge_id
             WHERE 
                bb.active = true
             GROUP BY -- Required when using an aggregate function like COUNT
                bb.id, p.name
             ORDER BY 
                p.name`
        );
        res.json(rows);
    } catch (error) {
        console.error('Error fetching blood bridges:', error);
        res.status(500).json({ error: 'Failed to fetch blood bridges.' });
    }
};


/**
 * Fetches patients who are due for a transfusion.
 * Logic: Finds patients where today's date is past their last transfusion + frequency.
 */
export const getDuePatients = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT id, name, blood_group, city, last_transfusion_date, frequency_in_days
       FROM patients
       WHERE 
         status = 'bridged' AND 
         last_transfusion_date IS NOT NULL AND 
         frequency_in_days IS NOT NULL AND
         (last_transfusion_date + frequency_in_days * INTERVAL '1 day') <= NOW()`
    );
    res.json(rows);
  } catch (error){
    console.error('Error fetching due patients:', error);
    res.status(500).json({ error: 'Failed to fetch due patients.' });
  }
};

/**
 * Fetches the top 10 donors for the gamification leaderboard.
 */
export const getLeaderboard = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT name, gamification_points, city 
       FROM users 
       WHERE user_type = 'donor' 
       ORDER BY gamification_points DESC 
       LIMIT 10`
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching leaderboard:', error);
    res.status(500).json({ error: 'Failed to fetch leaderboard data.' });
  }
};

// --- Other Endpoints (Placeholders for now) ---
export const getConfig = async (req, res) => { res.json({ message: "Config placeholder" }); };
export const getInboxMessages = async (req, res) => {
  try {
    // This query selects all messages that an admin has not yet marked as 'resolved'.
    const { rows } = await db.query(
      "SELECT id, user_phone, user_message, reason, created_at FROM inbox_messages WHERE status = 'pending' ORDER BY created_at ASC"
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching inbox messages:', error);
    res.status(500).json({ error: 'Failed to fetch inbox messages.' });
  }
};
export const escalateEmergency = async (req, res) => {
  const { requestId } = req.params;
  try {
    const result = await emergencyService.escalateRequest(requestId);
    console.log(`ADMIN ACTION: Escalated emergency request ${requestId}`);
    res.json(result);
  } catch (error) {
    console.error(`Error escalating emergency ${requestId}:`, error);
    res.status(500).json({ error: error.message || 'Failed to escalate emergency.' });
  }
};
export const resolveInboxMessage = async (req, res) => {
  const { messageId } = req.params;
  try {
    const { rowCount } = await db.query(
      "UPDATE inbox_messages SET status = 'resolved', resolved_at = NOW() WHERE id = $1 AND status = 'pending'",
      [messageId]
    );

    if (rowCount === 0) {
      return res.status(404).json({ message: "Pending message not found or it may have been already resolved." });
    }

    console.log(`ADMIN ACTION: Resolved inbox message ${messageId}`);
    res.json({ success: true, message: 'Message marked as resolved.' });
  } catch (error) {
    console.error(`Error resolving inbox message ${messageId}:`, error);
    res.status(500).json({ error: 'Failed to resolve message.' });
  }
};

```

`backend/src/controllers/webhookController.js`

```javascript
// backend/src/controllers/webhookController.js

// Import required dependencies
import config from '../config/config.js';
import db from '../config/db.js';
import emergencyService from '../services/emergencyService.js';
import registrationService from '../services/registrationService.js';
import responseService from '../services/responseService.js';
import patientService from '../services/patientService.js';
import donorPreferenceService from '../services/donorPreferenceService.js';
import aiRouterService from '../services/aiRouterService.js';
import faqService from '../services/faqService.js';
import gamificationService from '../services/gamificationService.js';
import whatsappService from '../services/whatsappService.js';
import bridgeService from '../services/bridgeService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';
import { detectLanguage } from '../utils/languageHelper.js';
import translationService from '../utils/translationService.js';
import { triggerInactiveDonorNudges, triggerAutomaticBridgeRequests } from '../services/schedulerService.js';
import loggingService from '../services/loggingService.js';

/**
 * Handles the GET request from Meta for webhook verification.
 */
const verifyToken = (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode === 'subscribe' && token === config.whatsappVerifyToken) {
    console.log('âœ… Webhook verified successfully!');
    return res.status(200).send(challenge);
  }

  console.warn('Webhook verification failed. Make sure your verify token is correct.');
  res.status(403).send('Verification failed');
};

/**
 * Processes a single, validated incoming WhatsApp message.
 */
const processMessage = async (messageData) => {
  const from = normalizePhoneNumber(messageData.from);

  // --- PRIORITY 0: Handle Non-Text Message Types ---
  if (messageData.type === 'interactive' && messageData.interactive.type === 'button_reply') {
    const buttonId = messageData.interactive.button_reply.id;
    console.log(`--- Interactive Reply --- From: ${from}, Button ID: ${buttonId}`);
    if (buttonId.startsWith('join_bridge_')) {
      await bridgeService.addDonorToBridge(buttonId.replace('join_bridge_', ''));
      await whatsappService.sendTextMessage(from, "Thank you for joining a Blood Bridge! You are now part of a dedicated life-saving team. â¤ï¸");
    } else if (buttonId.startsWith('decline_bridge_')) {
      await whatsappService.sendTextMessage(from, "No problem! We appreciate you being a regular donor and will keep you in mind for general requests.");
    }
    return;
  }
  
  if (messageData.type === 'location') {
    console.log(`--- Location Message --- From: ${from}`);
    await emergencyService.handleLocationReply(from, messageData.location);
    return;
  }

  if (messageData.type !== 'text') {
    console.log(`Ignoring non-text message of type '${messageData.type}' from ${from}.`);
    return;
  }

  // --- Text Message Processing ---
  let userMessage = messageData.text.body.trim();
  
  const detectedLang = await detectLanguage(userMessage);
  if (detectedLang && detectedLang !== 'en') {
      userMessage = await translationService.translateToEnglish(userMessage);
  }
  
  const lowerUserMessage = userMessage.toLowerCase();
  console.log(`--- Processing Message --- From: ${from}, Processed Message: "${userMessage}"`);
  await loggingService.logIncoming(from, userMessage);

  // --- PRIORITY 1: Rigid Commands & State-Based Replies ---
  
  // Smart parser for the multi-line donor registration format
  const registrationDetailsMatch = userMessage.match(/(?:name|full name):\s*(?<name>.+)\s*city:\s*(?<city>.+)\s*blood group:\s*(?<blood_group>.+)/is);
  if (registrationDetailsMatch) {
    console.log(`âœ… Message handled by: Donor Registration Details Parser.`);
    await registrationService.completeDonorRegistration(from, registrationDetailsMatch.groups);
    return;
  }
  
  // Keyword match for DONOR registration
  const isDonorRequest = lowerUserMessage.includes('donor') || lowerUserMessage.includes('donate');
  if (lowerUserMessage.includes('register') && isDonorRequest && !lowerUserMessage.includes('patient')) {
    console.log(`âœ… Message handled by: Donor Registration keyword.`);
    await registrationService.handleNewDonor({}, from);
    return;
  }

  // Keyword match for PATIENT registration
  if ((lowerUserMessage.includes('register') && lowerUserMessage.includes('patient')) || lowerUserMessage.includes('help for a thalassemia patient')) {
    console.log(`âœ… Message handled by: Patient Registration keyword.`);
    await patientService.handleNewPatient({}, from);
    return;
  }

  // Conversational flows and standard replies
  if (await patientService.processOnboardingReply(userMessage, from)) return;
  if (lowerUserMessage === 'apply' && await patientService.startApplication(from)) return;
  if (/^\d{6}$/.test(userMessage)) { await responseService.verifyOTPAndConfirm(from, userMessage); return; }
  if (lowerUserMessage === 'no') { await responseService.handleSimpleDecline(from); return; }
  const responseMatch = userMessage.match(/^(?:YES)\s+(\d{4})$/i);
  if (responseMatch) { await responseService.handleDonorReplyWithShortCode(from, responseMatch[1]); return; }
  if (lowerUserMessage === 'yes') {
    const { rows: [userWithCode] } = await db.query("SELECT last_request_short_code FROM users WHERE phone = $1", [from]);
    if (userWithCode && userWithCode.last_request_short_code) {
        await responseService.handleDonorReplyWithShortCode(from, userWithCode.last_request_short_code);
        return;
    }
  }

  // Demo commands
  if (lowerUserMessage.startsWith('/demo')) {
    console.log('DEMO MODE ACTIVATED');
    if (lowerUserMessage === '/demo nudge') {
        await triggerInactiveDonorNudges();
        await whatsappService.sendTextMessage(from, `ðŸŽ¬ Executed Inactive Donor Nudge.`);
    } else if (lowerUserMessage === '/demo bridge_request') {
        await triggerAutomaticBridgeRequests();
        await whatsappService.sendTextMessage(from, `ðŸŽ¬ Executed Automatic Bridge Requests.`);
    } else {
        await whatsappService.sendTextMessage(from, `Unknown demo command.`);
    }
    return;
  }

  // --- PRIORITY 2: AI-Powered Intent Routing (with context) ---
  console.log(`No direct keyword match found. Routing to AI with conversation context...`);
  const { rows: [user] } = await db.query('SELECT role FROM users WHERE phone = $1', [from]);
  const userRole = user ? user.role : 'Unregistered';
  
  const { rows: historyRows } = await db.query(
    `SELECT message, response FROM conversations WHERE user_phone = $1 ORDER BY created_at DESC LIMIT 3`,
    [from]
  );
  
  const chatHistory = historyRows.reverse().flatMap(row => [
    { role: 'user', parts: [{ text: row.message }] },
    ...(row.response ? [{ role: 'model', parts: [{ text: row.response }] }] : [])
  ]);

  const route = await aiRouterService.routeMessageWithContext(userMessage, userRole, chatHistory);
  
  if (route && route.tool) {
    console.log(`AI routed to tool: ${route.tool}`);
    switch (route.tool) {
      case 'handle_emergency_request':
        await emergencyService.handleEmergencyRequest(userMessage, from);
        break;
      case 'handle_donor_registration':
        await registrationService.handleNewDonor(route.params, from);
        break;
      case 'handle_patient_onboarding':
        await patientService.handleNewPatient(route.params, from);
        break;
      case 'get_my_dashboard': {
        const statusMessage = await gamificationService.getDonorStatus(from);
        await whatsappService.sendTextMessage(from, statusMessage);
        break;
      }
      case 'get_leaderboard': {
        const leaderboardMessage = await gamificationService.getLeaderboardMessage(from);
        await whatsappService.sendTextMessage(from, leaderboardMessage);
        break;
      }
      case 'handle_join_bridge_request': {
        const msg = await bridgeService.addDonorToBridgeByPhone(from);
        await whatsappService.sendTextMessage(from, msg);
        break;
      }
      case 'handle_snooze_request':
        await donorPreferenceService.handleSnooze(from, route.params);
        break;
      default:
        await faqService.handleFaq(userMessage, from);
        break;
    }
    return;
  }

  // --- PRIORITY 3: Final Fallback ---
  console.log(`AI did not select a tool. Handling as a general FAQ.`);
  await faqService.handleFaq(userMessage, from);
};

/**
 * The main entry point for the /webhook POST request.
 */
const handleMessage = async (req, res) => {
  res.sendStatus(200);

  try {
    const messageData = req.body.entry?.[0]?.changes?.[0]?.value?.messages?.[0];
    if (!messageData) {
      return;
    }

    const messageId = messageData.id;
    const { rows } = await db.query('SELECT 1 FROM processed_messages WHERE message_id = $1', [messageId]);
    if (rows.length > 0) {
      console.warn(`Duplicate message ignored: ${messageId}`);
      return;
    }
    
    await db.query('INSERT INTO processed_messages(message_id) VALUES($1)', [messageId]);
    await processMessage(messageData);

  } catch (error) {
    console.error('CRITICAL ERROR in handleMessage:', {
      message: error.message,
      stack: error.stack,
    });
  }
};

export default {
  verifyToken,
  handleMessage,
};

```

`backend/src/middleware/authMiddleware.js`

```javascript
// backend/src/middleware/authMiddleware.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';

// âœ… The function must be declared as a constant named 'authMiddleware'
const authMiddleware = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authorization token is missing or malformed' });
  }

  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, config.jwtSecret);
    req.user = decoded;
    next();
  } catch (error) {
    console.error("JWT Verification Error:", error.message);
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
};

// âœ… This line then exports that constant
export default authMiddleware;

```

`backend/src/middleware/checkRole.js`

```javascript
// backend/src/middleware/checkRole.js

const checkRole = (roles) => {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: 'Forbidden: No role assigned' });
    }
    const userRole = req.user.role;
    if (roles.includes(userRole)) {
      return next();
    }
    return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
  };
};

export default checkRole; // <-- CORRECTED LINE

```

`backend/src/middleware/verifyWebhook.js`

```javascript
// backend/src/middleware/verifyWebhook.js
import crypto from 'crypto';
import config from '../config/config.js';

/**
 * Middleware to verify WhatsApp webhook POST requests.
 * - Skips signature verification for GET (used by Meta for challenge verification).
 * - Validates signature for POST requests to ensure authenticity.
 */
export const verifyWebhook = (req, res, next) => {
  // Allow GET requests (Meta verification step) to pass through.
  if (req.method === 'GET') {
    return next();
  }

  // Get the signature from the request header.
  const signature = req.headers['x-hub-signature-256'];
  if (!signature) {
    console.warn('Signature missing for POST webhook');
    return res.status(401).json({ message: 'Signature missing' });
  }

  // --- THIS IS THE CORRECTED SECTION ---
  // Create an HMAC (Hash-based Message Authentication Code) using sha256.
  // We use the `whatsappAppSecret` as the key.
  const hmac = crypto.createHmac('sha256', config.whatsappAppSecret);

  // We MUST use the raw request body string that we saved earlier in server.js.
  // Using `req.body` here will fail because it's already parsed JSON.
  hmac.update(req.rawBody);
  const expectedSignature = `sha256=${hmac.digest('hex')}`;
  // --- END OF CORRECTION ---

  // Compare the signature from Meta with the one we calculated.
  // We use a timing-safe comparison to enhance security.
  // An invalid signature means the request might be forged.
  if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))) {
    console.warn('Signature mismatch for POST webhook. Check your WHATSAPP_APP_SECRET.');
    return res.status(401).json({ message: 'Invalid signature' });
  }

  // If the signatures match, the request is authentic. Proceed to the next middleware.
  next();
};

```

`backend/src/routes/adminRoutes.js`

```javascript
// backend/src/routes/adminRoutes.js
import express from 'express';
import {
  login,
  createBridgeForPatient,
  closeEmergency,
  requestBridgeTransfusion,
  getDashboardStats,
  getBloodGroupStats,
  getPatients,
  getActiveEmergencies,
  getBloodBridges,
  getDuePatients,
  getLeaderboard,
  getInboxMessages,
  escalateEmergency,
  resolveInboxMessage,
  getConfig
} from '../controllers/adminController.js';
import authMiddleware from '../middleware/authMiddleware.js';
import checkRole from '../middleware/checkRole.js';

const router = express.Router();

// Public (no auth needed)
router.post('/login', login);

// All routes below this require auth
router.use(authMiddleware);

// --- DASHBOARD GET ROUTES ---
router.get('/config', checkRole(['Admin']), getConfig);
router.get('/stats', checkRole(['Admin']), getDashboardStats);
router.get('/stats/blood-groups', checkRole(['Admin']), getBloodGroupStats);
router.get('/patients', checkRole(['Admin']), getPatients);
router.get('/patients/due', checkRole(['Admin']), getDuePatients);
router.get('/emergencies', checkRole(['Admin']), getActiveEmergencies);
router.get('/bridges', checkRole(['Admin']), getBloodBridges);
router.get('/leaderboard', checkRole(['Admin']), getLeaderboard);
router.get('/inbox', checkRole(['Admin']), getInboxMessages);

// --- ACTION ROUTES ---
router.post('/patients/:patientId/create-bridge', checkRole(['Admin']), createBridgeForPatient);
router.post('/emergencies/:requestId/close', checkRole(['Admin']), closeEmergency);
router.post('/emergencies/:requestId/escalate', checkRole(['Admin']), escalateEmergency);
router.post('/bridges/:bridgeId/request', checkRole(['Admin']), requestBridgeTransfusion);
router.post('/inbox/:messageId/resolve', checkRole(['Admin']), resolveInboxMessage);

export default router;

```

`backend/src/services/aiRouterService.js`

```javascript
// backend/src/services/aiRouterService.js
import { GoogleGenerativeAI } from '@google/generative-ai';
import { TOOL_DEFINITIONS } from './aiTools.js'; // âœ… This import MUST be in this file.
import config from '../config/config.js';

class AIRouterService {
  constructor() {
    if (!config.geminiApiKey) {
      throw new Error("GEMINI_API_KEY is not set.");
    }
    this.genAI = new GoogleGenerativeAI(config.geminiApiKey);
    this.model = this.genAI.getGenerativeModel({
      model: 'gemini-1.5-flash-latest',
      // This line now works because TOOL_DEFINITIONS is correctly imported above.
      tools: { functionDeclarations: TOOL_DEFINITIONS }
    });
  }

  // âœ… This is the complete, context-aware version of this function.
  async routeMessageWithContext(userMessage, userRole, chatHistory = []) {
    const systemPrompt = `You are "Bridge AI", an AI assistant. Your goal is to understand the user's message in the context of the conversation and call the appropriate function. The user's role is "${userRole}".`;
    
    const fullHistory = [
      { role: "user", parts: [{ text: systemPrompt }] },
      { role: "model", parts: [{ text: "Understood." }] },
      ...chatHistory
    ];
    
    try {
      const chat = this.model.startChat({ history: fullHistory });
      const result = await chat.sendMessage(userMessage);
      const call = result.response.functionCalls()?.[0];
      
      if (call) {
        console.log(`AI decided to call tool: ${call.name} with params:`, call.args);
        return { tool: call.name, params: call.args };
      }
      console.log("AI did not call a specific tool for this message.");
      return null;
    } catch (error) {
      console.error('Error routing message with Gemini:', error.message);
      return null;
    }
  }
}

export default new AIRouterService();

```

`backend/src/services/aiTools.js`

```javascript
// backend/src/services/aiTools.js

/**
Â * TOOL_DEFINITIONS is a manifest of functions the Gemini AI can call.
Â * The descriptions are critical, as they tell the AI *when* to use each tool.
Â */
export const TOOL_DEFINITIONS = [
Â  {
Â  Â  name: 'handle_emergency_request',
Â  Â  description: `Use for any urgent, one-time blood request. The message may contain details like blood group, city, or hospital.`,
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {
Â  Â  Â  Â  patient_name: { type: 'string', description: 'Name of the patient needing blood. If not mentioned, use "Unknown".' },
Â  Â  Â  Â  blood_group: { type: 'string', description: 'The blood group needed, like A+, O-, AB+.' },
Â  Â  Â  Â  city: { type: 'string', description: 'The city where the hospital is located.' }
Â  Â  Â  },
Â  Â  Â  required: ['blood_group', 'city']
Â  Â  }
Â  },
  {
    // âœ… UPDATED: This tool can now extract parameters from a detailed message.
    name: 'handle_patient_onboarding',
    description: `Use when a user wants to register a PATIENT for long-term support. This is for long-term care, not one-time emergencies. Extract the patient's name, city, and blood group if provided.`,
    parameters: {
      type: 'object',
      properties: {
        patient_name: { type: 'string', description: 'The name of the patient. Default to "the patient" if not specified.' },
        city: { type: 'string', description: 'The city where the patient needs support.' },
        blood_group: { type: 'string', description: "The patient's blood group." }
      },
      required: [] // Parameters are optional, the bot can ask for them if missing.
    }
  },
Â  {
    // âœ… This description is now more specific to donors.
Â  Â  name: 'handle_donor_registration',
Â  Â  description: `Use when a user wants to register as a DONOR or makes a generic registration request like "register me" or "create an account". Key phrases are "I want to donate", "register me as a donor", or "sign me up". Do NOT use this tool if the user mentions "patient".`,
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {
Â  Â  Â  Â  name: { type: 'string', description: 'Full name of the new donor. Default to "Unknown".' },
Â  Â  Â  Â  blood_group: { type: 'string', description: 'The blood group of the person. Default to "Unknown".' },
Â  Â  Â  Â  city: { type: 'string', description: 'The city where the donor lives. Default to "Unknown".' }
Â  Â  Â  },
Â  Â  Â  required: []
Â  Â  }
Â  },
  {
    name: 'handle_join_bridge_request',
    description: `Use when an EXISTING registered donor specifically asks to join a "Blood Bridge". This is a rotational system for supporting a specific patient.`,
    parameters: { 
      type: 'object', 
      properties: {}
    }
  },

Â  {
Â  Â  name: 'handle_snooze_request',
Â  Â  description: 'Use when a donor wants to temporarily pause notifications. It can understand durations like "a month", "10 days", "2 weeks".',
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {
Â  Â  Â  Â  duration: { type: 'integer', description: 'The number value for the duration (e.g., 10 for "10 days").' },
Â  Â  Â  Â  unit: { type: 'string', enum: ['day', 'week', 'month'], description: 'The unit of time for the snooze.' }
Â  Â  Â  },
Â  Â  Â  required: ['duration', 'unit']
Â  Â  }
Â  },
Â  {
Â  Â  name: 'get_my_dashboard',
Â  Â  description: 'Use this when a registered donor asks for their personal status, points, badges, or "mydashboard".',
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {},
Â  Â  Â  required: []
Â  Â  }
Â  },
Â  {
Â  Â  name: 'get_leaderboard',
Â  Â  description: 'Use this when a user asks to see the "leaderboard", "top donors", or "rankings".',
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {},
Â  Â  Â  required: []
Â  Â  }
Â  },
];

```

`backend/src/services/bridgeCoordinationService.js`

```javascript
// backend/src/services/bridgeCoordinationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateShortCode } from '../utils/otpHelper.js';

class BridgeCoordinationService {
  async requestTransfusion(bridgeId) {
    const { rows: [bridge] } = await db.query(
      `SELECT bb.*, p.name as patient_name
       FROM blood_bridges bb
       JOIN patients p ON bb.patient_id = p.id
       WHERE bb.id = $1`,
      [bridgeId]
    );
    if (!bridge) throw new Error(`Blood Bridge with ID ${bridgeId} not found.`);

    // --- NEW LOGIC: PREVENT DUPLICATE REQUESTS ---
    if (bridge.active_request_id) {
      throw new Error(`Request failed: Patient ${bridge.patient_name} already has an active bridge request.`);
    }
    // --- END NEW LOGIC ---

    const { rows: members } = await db.query(
      // Find the next donor who is currently 'available'
      `SELECT u.id, u.name, u.phone
       FROM bridge_members bm
       JOIN users u ON bm.donor_id = u.id
       WHERE bm.bridge_id = $1 AND bm.status = 'active' AND u.availability_status = 'available'
       ORDER BY bm.position ASC`,
      [bridgeId]
    );

    if (members.length === 0) {
      // This is a "Bridge Failure" scenario. We need to escalate.
      // For now, we'll throw an error that the admin will see.
      // In Task 4 (Escalation), we will automate this.
      throw new Error(`No available donors found in the bridge for ${bridge.patient_name}. Please escalate to a general emergency.`);
    }

    const donorToNotify = members[0]; // The SQL query now only returns available donors in order

    const shortCode = generateShortCode();
    // Create the request and get its ID back
    const { rows: [newRequest] } = await db.query(
      `INSERT INTO emergency_requests (patient_name, blood_group, city, requested_by_phone, short_code, request_type, bridge_id, units_needed)
       VALUES ($1, $2, $3, 'system', $4, 'bridge', $5, 1) RETURNING id;`,
      [bridge.patient_name, bridge.blood_group, bridge.city, shortCode, bridge.id]
    );

    // --- NEW LOGIC: LINK THE ACTIVE REQUEST TO THE BRIDGE ---
    await db.query(
        'UPDATE public.blood_bridges SET active_request_id = $1 WHERE id = $2',
        [newRequest.id, bridgeId]
    );
    // --- END NEW LOGIC ---

    const message = `Hi ${donorToNotify.name}, it's your turn in the Blood Bridge for patient *${bridge.patient_name}*.\n\nYour help is needed for their scheduled transfusion. Please reply with *YES ${shortCode}* to confirm your availability.`;
    await whatsappService.sendTextMessage(donorToNotify.phone, message);

    return { success: true, message: `Successfully notified ${donorToNotify.name} for patient ${bridge.patient_name}.` };
  }
  
  async rotateBridge(bridgeId, client = db) {
    // This function now does two things: rotates the position AND clears the active request ID.
    const { rows: [bridge] } = await client.query('SELECT rotation_position FROM blood_bridges WHERE id = $1', [bridgeId]);
    const { rows: [{ count }] } = await client.query('SELECT COUNT(*) FROM bridge_members WHERE bridge_id = $1 AND status = \'active\'', [bridgeId]);

    if (!bridge || count === '0') {
      console.error(`Cannot rotate bridge ${bridgeId}: Bridge or members not found.`);
      return;
    }

    const totalMembers = parseInt(count, 10);
    // We use the current position to find the next one, ensuring rotation
    const currentPositionInList = (bridge.rotation_position - 1);
    const nextPosition = (currentPositionInList % totalMembers) + 1;

    // Update bridge: clear active request and set new rotation position
    await client.query(
      'UPDATE blood_bridges SET rotation_position = $1, active_request_id = NULL WHERE id = $2',
      [nextPosition, bridgeId]
    );
    console.log(`Blood Bridge ${bridgeId} rotated successfully to position ${nextPosition} and cleared active request.`);
  }  // In backend/src/services/bridgeCoordinationService.js, inside the class

  /**
   * Finds all bridged patients who are due for a transfusion and initiates the request.
   * This is designed to be run automatically by a scheduler.
   */
  async triggerAutomaticBridgeRequests() {
    console.log('CRON JOB: Checking for due bridge patients...');
    try {
      // 1. Find all patients who are bridged and due for a transfusion today or in the past.
      const { rows: duePatients } = await db.query(
        `SELECT p.id, p.name, bb.id as bridge_id
         FROM patients p
         JOIN blood_bridges bb ON p.id = bb.patient_id
         WHERE 
           p.status = 'bridged' AND 
           p.last_transfusion_date IS NOT NULL AND 
           p.frequency_in_days IS NOT NULL AND
           (p.last_transfusion_date + p.frequency_in_days * INTERVAL '1 day') <= NOW() AND
           bb.active_request_id IS NULL -- IMPORTANT: Only trigger if there isn't one already active
        `
      );

      if (duePatients.length === 0) {
        console.log('CRON JOB: No patients are due for an automatic bridge request today.');
        return;
      }

      console.log(`CRON JOB: Found ${duePatients.length} patient(s) due for transfusion. Initiating requests...`);

      // 2. Loop through each due patient and call the existing requestTransfusion function.
      for (const patient of duePatients) {
        console.log(`CRON JOB: Initiating request for patient ${patient.name} (Bridge ID: ${patient.bridge_id})`);
        try {
          // We reuse the same logic that the admin dashboard button uses.
          await this.requestTransfusion(patient.bridge_id);
        } catch (error) {
          console.error(`CRON JOB: Failed to initiate request for bridge ${patient.bridge_id}. Reason: ${error.message}`);
          // In a production system, you might send an alert to an admin here.
        }
      }
    } catch (error) {
      console.error("CRITICAL ERROR in cron job triggerAutomaticBridgeRequests:", error);
    }
  }

/**
 * Finds all bridged patients who are due for a transfusion and initiates the request.
 * This is designed to be run automatically by a scheduler.
 */
async triggerAutomaticBridgeRequests() {
  console.log('CRON JOB: Checking for due bridge patients...');
  try {
    // 1. Find all patients who are bridged and due for a transfusion today or in the past.
    const { rows: duePatients } = await db.query(
      `SELECT p.id, p.name, bb.id as bridge_id
       FROM patients p
       JOIN blood_bridges bb ON p.id = bb.patient_id
       WHERE 
         p.status = 'bridged' AND 
         p.last_transfusion_date IS NOT NULL AND 
         p.frequency_in_days IS NOT NULL AND
         (p.last_transfusion_date + p.frequency_in_days * INTERVAL '1 day') <= NOW() AND
         bb.active_request_id IS NULL -- IMPORTANT: Only trigger if there isn't one already active
      `
    );

    if (duePatients.length === 0) {
      console.log('CRON JOB: No patients are due for an automatic bridge request today.');
      return;
    }

    console.log(`CRON JOB: Found ${duePatients.length} patient(s) due for transfusion. Initiating requests...`);

    // 2. Loop through each due patient and call the existing requestTransfusion function.
    for (const patient of duePatients) {
      console.log(`CRON JOB: Initiating request for patient ${patient.name} (Bridge ID: ${patient.bridge_id})`);
      try {
        // We reuse the same logic that the admin dashboard button uses.
        await this.requestTransfusion(patient.bridge_id);
      } catch (error) {
        console.error(`CRON JOB: Failed to initiate request for bridge ${patient.bridge_id}. Reason: ${error.message}`);
        // In a production system, you might send an alert to an admin here.
      }
    }
  } catch (error) {
    console.error("CRITICAL ERROR in cron job triggerAutomaticBridgeRequests:", error);
  }
}
}

export default new BridgeCoordinationService();

```

`backend/src/services/bridgeService.js`

```javascript
// backend/src/services/bridgeService.js
import db from '../config/db.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class BridgeService {
  /**
   * Finds the best active bridge for a new donor to join based on city and blood group.
   * "Best" is defined as the bridge with the fewest members, to ensure balance.
   */
  async findBestBridgeForDonor(city, bloodGroup) {
    const query = `
      SELECT bb.id, bb.name FROM blood_bridges bb
      LEFT JOIN bridge_members bm ON bb.id = bm.bridge_id
      WHERE bb.city ILIKE $1 AND bb.blood_group = $2 AND bb.active = true
      GROUP BY bb.id, bb.name
      HAVING COUNT(bm.id) < 10 -- Only consider bridges that are not full
      ORDER BY COUNT(bm.id) ASC, bb.created_at ASC -- Prioritize the least full, oldest bridge
      LIMIT 1;
    `;
    const { rows: [bestBridge] } = await db.query(query, [`%${city}%`, bloodGroup]);
    return bestBridge;
  }

  /**
   * Adds a donor to the best available bridge.
   * @param {string} donorId - The UUID of the donor to add.
   */
  async addDonorToBridge(donorId) {
    try {
      const { rows: [donor] } = await db.query('SELECT city, blood_group FROM users WHERE id = $1', [donorId]);
      if (!donor) throw new Error('Donor not found.');
      
      const bridge = await this.findBestBridgeForDonor(donor.city, donor.blood_group);
      if (!bridge) {
        console.log(`No active bridge with available space found for ${donor.city}/${donor.blood_group}.`);
        return { success: true, status: 'no_bridge_found' };
      }

      await db.query(
        "INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, (SELECT COALESCE(MAX(position), 0) + 1 FROM bridge_members WHERE bridge_id = $1)) ON CONFLICT DO NOTHING",
        [bridge.id, donorId]
      );

      console.log(`Successfully added donor ${donorId} to bridge: ${bridge.name} (${bridge.id}).`);
      return { success: true, status: 'added_to_bridge' };
    } catch (error) {
      console.error('Error adding donor to bridge:', error);
      return { success: false, error };
    }
  }

  /**
   * Handles a request from a donor to join a bridge via their phone number.
   */
  async addDonorToBridgeByPhone(donorPhone) {
    const sanitizedPhone = normalizePhoneNumber(donorPhone);
    try {
      const { rows: [donor] } = await db.query('SELECT id, name, city, blood_group FROM users WHERE phone = $1', [sanitizedPhone]);
      if (!donor) {
        return "It looks like you're not registered yet. Please register first!";
      }
     
      const { rows: [existingMember] } = await db.query('SELECT id FROM bridge_members WHERE donor_id = $1', [donor.id]);
      if (existingMember) {
        return `Thank you, ${donor.name}! You are already a valued member of a Blood Bridge.`;
      }
      const bridge = await this.findBestBridgeForDonor(donor.city, donor.blood_group);
      if (!bridge) {
        return `Thank you for your interest, ${donor.name}! We don't have a Blood Bridge matching your profile right now, but we'll notify you when one becomes available.`;
      }
      await db.query(
        "INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, (SELECT COALESCE(MAX(position), 0) + 1 FROM bridge_members WHERE bridge_id = $1)) ON CONFLICT DO NOTHING",
        [bridge.id, donor.id]
      );
     
      return `Welcome to ${bridge.name}! You are now part of a dedicated life-saving team. â¤ï¸`;
    } catch (error) {
      console.error('Error adding donor to bridge by phone:', error);
      return 'Sorry, we encountered an error. Please try again later.';
    }
  }

  /**
   * Populates a newly created bridge with the best-matched donors from the general pool.
   */
  async populateNewBridge(bridgeId, city, bloodGroup, pincode) {
    try {
      console.log(`Populating bridge ${bridgeId} for city: ${city}, blood group: ${bloodGroup}, pincode: ${pincode}`);
      const { rows: bestDonors } = await db.query(
        'SELECT donor_id, final_score FROM find_donors_for_bridge($1, $2, $3, $4)',
        [city, bloodGroup, pincode, 8]
      );
      
      if (!bestDonors || bestDonors.length === 0) {
        console.warn(`No donors found for bridge ${bridgeId}`);
        return { success: true, count: 0 };
      }

      const insertQueries = bestDonors.map((donor, index) =>
        db.query(
          'INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, $3)',
          [bridgeId, donor.donor_id, index + 1]
        )
      );

      await Promise.all(insertQueries);
      console.log(`Successfully populated bridge ${bridgeId} with ${bestDonors.length} donors`);
      return { success: true, count: bestDonors.length };
    } catch (error) {
      console.error(`Error populating bridge ${bridgeId}:`, {
        error: error.message, city, bloodGroup, pincode,
      });
      throw new Error(`Failed to populate bridge: ${error.message}`);
    }
  }
}

export default new BridgeService(); 

```

`backend/src/services/donorPreferenceService.js`

```javascript
// backend/src/services/donorPreferenceService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class DonorPreferenceService {
  /**
   * Sets a snooze period for a donor, pausing notifications.
   * @param {string} phone - The donor's phone number.
   * @param {object} params - Parameters from the AI, e.g., { duration: 1, unit: 'week' }.
   */
  async handleSnooze(phone, params) {
    const { duration = 15, unit = 'day' } = params; // Default to 15 days if AI provides no params
    
    try {
      const interval = `${duration} ${unit}`;
      const { rows: [user] } = await db.query(
        "UPDATE users SET snooze_until = NOW() + $1::interval WHERE phone = $2 RETURNING snooze_until",
        [interval, phone]
      );

      if (user && user.snooze_until) {
        const snoozeDate = new Date(user.snooze_until).toLocaleDateString('en-IN');
        const message = `Got it. I've paused all non-critical notifications for you until ${snoozeDate}. We'll reach out again after that. Thank you for being a donor!`;
        await whatsappService.sendTextMessage(phone, message);
      }
    } catch (error) {
      console.error(`Error setting snooze for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while setting your preferences.");
    }
  }

  /**
   * Sets the Do Not Disturb (DND) status for a donor, permanently stopping notifications.
   * @param {string} phone - The donor's phone number.
   */
  async handleDnd(phone) {
    try {
      await db.query(
        "UPDATE users SET dnd_status = true, availability_status = 'unavailable' WHERE phone = $1",
        [phone]
      );
      const message = "You have been unsubscribed from all future notifications. We're sad to see you go, but we respect your decision. If you ever change your mind, just send 'Register' to sign up again.";
      await whatsappService.sendTextMessage(phone, message);
    } catch (error) {
      console.error(`Error setting DND for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while updating your DND status.");
    }
  }
}

export default new DonorPreferenceService();

```

`backend/src/services/emergencyService.js`

```javascript
// backend/src/services/emergencyService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import aiRouterService from './aiRouterService.js';
import mlService from './mlService.js';
import geocodingService from './geocodingService.js';
import { getDistanceInKm } from '../utils/distanceHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

const VALID_BLOOD_GROUPS = ['A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'];
const activeTimeouts = new Map();

class EmergencyService {
  async handleEmergencyRequest(userMessage, requesterPhone) {
    const sanitizedPhone = normalizePhoneNumber(requesterPhone);
    try {
      const route = await aiRouterService.routeMessageWithContext(userMessage, 'Unregistered');
      if (route && route.tool === 'handle_emergency_request' && route.params.blood_group && route.params.city) {
        console.log("AI successfully extracted details:", route.params);
        await this.createEmergencyRequest(route.params, sanitizedPhone);
      } else {
        console.log('AI could not extract necessary details. Prompting user.');
        const followupMessage = "I understand this is an emergency. To find a donor, please provide the patient's blood group (e.g., A+, O-) and the city where the hospital is located.";
        await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);
      }
    } catch (error) {
      console.error('CRITICAL ERROR in handleEmergencyRequest:', error);
      await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }  

  async createEmergencyRequest(params, requesterPhone) {
    const { 
      patient_name = 'Unknown', 
      blood_group, 
      city, 
      hospital_name = 'Unknown', 
      units_needed = 1
    } = params;
    try {
      const normalizedBG = normalizeBloodGroup(blood_group);
      if (!VALID_BLOOD_GROUPS.includes(normalizedBG)) {
        const validationErrorMessage = `Sorry, "${blood_group}" is not a recognized blood group. Please use a valid one (e.g., O+, AB-).`;
        await whatsappService.sendTextMessage(requesterPhone, validationErrorMessage);
        return;
      }
      
      const coords = await geocodingService.getCoords(hospital_name, city, null).catch(err => {
        console.error("Geocoding service failed, but continuing without coordinates.", err);
        return null;
      });

      const shortCode = Math.floor(1000 + Math.random() * 9000).toString();

      const { rows: [request] } = await db.query(
        `INSERT INTO emergency_requests (patient_name, blood_group, city, hospital_name, requested_by_phone, short_code, latitude, longitude, units_needed)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *;`,
        [patient_name, normalizedBG, city, hospital_name, requesterPhone, shortCode, coords?.latitude, coords?.longitude, units_needed]
      );
      
      console.log(`Successfully created emergency request ID: ${request.id}`);
      await whatsappService.sendTextMessage(requesterPhone, `âœ… Emergency request active! We are now running a hyperlocal search for *${patient_name}*.`);
      
      await this.findAndNotifyDonors(request);
    } catch (error) {
      console.error('CRITICAL ERROR creating emergency request in database:', error);
      await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }
  
  async findAndNotifyDonors(request) {
    const TIMEOUT_IN_MINUTES = 2;
    const { id: requestId, requested_by_phone } = request;
    
    try {
      // 1. Find all donors who have already been contacted for this request.
      const { rows: notifiedDonors } = await db.query(
        'SELECT donor_id FROM donor_responses WHERE request_id = $1',
        [requestId]
      );
      const excludedDonorIds = notifiedDonors.map(d => d.donor_id);

      // 2. Find the next best available donors.
      let topScoredDonors = await this.findAndRankGeneralDonors(request.blood_group, request.city, excludedDonorIds);

      // 3. Handle the case where no donors are left.
      if (topScoredDonors.length === 0) {
        console.warn(`Search complete for request ${requestId}: No new donors found.`);
        const alertMessage = `âš ï¸ We have contacted all available donors in our network for *${request.patient_name}*. This request has been flagged for admin review.`;
        await whatsappService.sendTextMessage(requested_by_phone, alertMessage);
        await db.query("INSERT INTO inbox_messages (user_phone, user_message, reason) VALUES ($1, $2, $3)", [requested_by_phone, `Donor search exhausted for patient ${request.patient_name}`, 'Donor Search Exhausted']);
        return;
      }

      // 4. Select only the single best donor from the list.
      const bestDonor = topScoredDonors[0];
      
      const notificationMessage = 
          `ðŸš¨ URGENT: A patient needs your help!\n\n` +
          `Patient: *${request.patient_name}*\n` +
          `Blood Group: *${request.blood_group}*\n` +
          `Location: ${request.hospital_name}, ${request.city}\n\n` +
          `To confirm you can donate, please reply with: *YES ${request.short_code}*\n\n` +
          `If you are unable to help, please reply "NO" so we can find another hero quickly.`;
        
      // 5. Log the attempt and send the message to the single best donor.
      await db.query(`INSERT INTO donor_responses (donor_id, request_id, response) VALUES ($1, $2, 'pending') ON CONFLICT (donor_id, request_id) DO UPDATE SET response = 'pending'`, [bestDonor.id, requestId]);
      await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [bestDonor.id]);
      await whatsappService.sendTextMessage(bestDonor.phone, notificationMessage);
      
      // 6. Inform the requester and set the automatic escalation timeout.
      const adminMessage = `âœ… Search ongoing... Notifying the best match: *${bestDonor.name}*. If they don't respond in ${TIMEOUT_IN_MINUTES} minutes, we will contact the next donor.`;
      await whatsappService.sendTextMessage(requested_by_phone, adminMessage);

      const timeoutId = setTimeout(() => {
        console.log(`[TIMEOUT] Donor ${bestDonor.name} did not respond for request ${requestId}. Escalating...`);
        this.findNextDonorForRequest(requestId);
      }, TIMEOUT_IN_MINUTES * 60 * 1000);

      activeTimeouts.set(requestId.toString(), timeoutId);

    } catch (error) {
      console.error(`CRITICAL ERROR in findAndNotifyDonors for request ${requestId}:`, error);
      await whatsappService.sendTextMessage(requested_by_phone, 'We encountered a system error while searching for donors. Our team has been notified.');
    }
  }

  async findNextDonorForRequest(requestId) {
    console.log(`[ESCALATION] Finding next donor batch for request ${requestId}`);
    this.clearEmergencyTimeout(requestId);
    const { rows: [requestInfo] } = await db.query(`SELECT * FROM emergency_requests WHERE id = $1`, [requestId]);
    
    if (requestInfo && requestInfo.status === 'active') {
      await this.findAndNotifyDonors(requestInfo);
    } else {
      console.warn(`[ESCALATION] Not proceeding for request ${requestId}, status is '${requestInfo ? requestInfo.status : 'NOT FOUND'}'`);
    }
  }

  async escalateRequest(requestId) {
    const BATCH_SIZE = 10;
    try {
      const { rows: [request] } = await db.query(
          'SELECT * FROM emergency_requests WHERE id = $1 AND status = \'active\'',
          [requestId]
      );
      if (!request) {
          throw new Error('Active emergency request not found.');
      }

      const { rows: notifiedDonors } = await db.query(
          'SELECT donor_id FROM donor_responses WHERE request_id = $1',
          [requestId]
      );
      const excludedDonorIds = notifiedDonors.map(d => d.donor_id);
      console.log(`Escalating request ${requestId}. Excluding ${excludedDonorIds.length} already-notified donor(s).`);
      
      const nextDonors = await this.findAndRankGeneralDonors(
          request.blood_group,
          request.city,
          excludedDonorIds
      );
      if (nextDonors.length === 0) {
          throw new Error('No additional available donors found in the network for this request.');
      }

      const batchToNotify = nextDonors.slice(0, BATCH_SIZE);
      const notificationPromises = batchToNotify.map(async (donor) => {
          try {
              const notificationMessage = `ðŸš¨ URGENT (Escalated): You are a top match for an emergency!\n\nPatient *${request.patient_name}* needs your help (${request.blood_group}).\n\nReply *YES ${request.short_code}* to help.`;
              
              await db.query(`INSERT INTO donor_responses (donor_id, request_id, response) VALUES ($1, $2, 'pending') ON CONFLICT (donor_id, request_id) DO NOTHING;`, [donor.id, requestId]);
              const result = await whatsappService.sendTextMessage(donor.phone, notificationMessage);
              
              if(result.success) {
                  await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [donor.id]);
              }
          } catch (err) {
              console.error(`Failed to notify donor ${donor.id} for request ${requestId}:`, err.message);
          }
      });

      await Promise.all(notificationPromises);
      const adminMessage = `âœ… Escalation successful. Notified a batch of ${batchToNotify.length} new top-ranked donors.`;
      await whatsappService.sendTextMessage(request.requested_by_phone, adminMessage);
      
      return { success: true, message: `Successfully escalated request and notified ${batchToNotify.length} new donors.` };
    } catch (error) {
      console.error(`CRITICAL ERROR during escalation for request ${requestId}:`, error);
      throw error;
    }
  }
  
  clearEmergencyTimeout(requestId) {
    if (activeTimeouts.has(requestId.toString())) {
      clearTimeout(activeTimeouts.get(requestId.toString()));
      activeTimeouts.delete(requestId.toString());
      console.log(`[TIMEOUT CLEARED] Timeout for request ${requestId} has been stopped.`);
    }
  }

  async findAndRankGeneralDonors(bloodGroup, city, excludedDonorIds = []) {
    const { rows: availableDonors } = await db.query(
      `SELECT id, name, phone, last_donation, notifications_received, donations_confirmed, streak_count, latitude, longitude
       FROM users
       WHERE user_type = 'donor' AND blood_group = $1 AND city ILIKE $2
         AND availability_status = 'available' AND dnd_status = false
         AND (snooze_until IS NULL OR snooze_until < NOW())
         AND id NOT IN (SELECT unnest($3::uuid[]))
       LIMIT 50;`,
      [normalizeBloodGroup(bloodGroup), city, excludedDonorIds]
    );
    if (!availableDonors || availableDonors.length === 0) return [];
    
    const scoringPromises = availableDonors.map(donor => mlService.scoreSingleDonor(donor));
    const results = await Promise.allSettled(scoringPromises);
    
    const scoredDonors = availableDonors.map((donor, index) => {
        const score = results[index].status === 'fulfilled' ? results[index].value.final_score : 0;
        return { ...donor, final_score: score };
    });
    
    scoredDonors.sort((a, b) => b.final_score - a.final_score);
    return scoredDonors;
  }
}

export default new EmergencyService();

```

`backend/src/services/engagementService.js`

```javascript
// backend/src/services/engagementService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class EngagementService {
  /**
   * Finds donors whose 90-day cooldown period has ended and reminds them
   * that they are now eligible to donate again.
   */
  async sendEligibilityReminders() {
    console.log('CRON JOB: Running sendEligibilityReminders...');
    try {
      // 1. Find all donors who are ready to be re-activated.
      // - Their cooldown must have expired (cooldown_until <= NOW()).
      // - Their status must currently be 'unavailable' (from their last donation).
      // - They must not have opted out of all notifications (dnd_status = false).
      const { rows: eligibleDonors } = await db.query(
        `SELECT id, name, phone
         FROM users
         WHERE user_type = 'donor'
           AND availability_status = 'unavailable'
           AND dnd_status = false
           AND cooldown_until <= NOW()`
      );

      if (eligibleDonors.length === 0) {
        console.log('CRON JOB: No donors are newly eligible today.');
        return;
      }

      console.log(`CRON JOB: Found ${eligibleDonors.length} newly eligible donors. Preparing to send reminders.`);

      // 2. Prepare all the database updates.
      // We will collect all the user IDs to update their status in a single efficient query.
      const donorIdsToUpdate = eligibleDonors.map(donor => donor.id);
      const updatePromise = db.query(
        "UPDATE users SET availability_status = 'available' WHERE id = ANY($1::uuid[])",
        [donorIdsToUpdate]
      );

      // 3. Prepare all the WhatsApp messages.
      // We will send messages concurrently for maximum speed.
      const messagePromises = eligibleDonors.map(donor => {
        const message = `Hi ${donor.name}! ðŸ‘‹\n\nGreat news! Your 90-day waiting period is over, and you are now eligible to save a life again.\n\nYour status has been updated to "Available". Thank you for being a vital part of the BloodBridge community! â¤ï¸`;
        return whatsappService.sendTextMessage(donor.phone, message);
      });

      // 4. Execute all promises (database updates and messages).
      // Promise.allSettled is used so that if one message fails, it doesn't stop the others.
      const results = await Promise.allSettled([updatePromise, ...messagePromises]);

      // 5. Log the results for monitoring.
      let successCount = 0;
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          if (index > 0) successCount++; // Don't count the DB update as a message
        } else {
          console.error(`CRON JOB: Failed to process reminder for donor ID ${donorIdsToUpdate[index - 1]}:`, result.reason);
        }
      });
      console.log(`CRON JOB: Successfully sent ${successCount} eligibility reminders.`);
      console.log(`CRON JOB: Updated ${donorIdsToUpdate.length} donors to 'available' status.`);

    } catch (error) {
      console.error('CRITICAL ERROR in cron job sendEligibilityReminders:', error);
    }
  }

  /**
   * Finds active, eligible donors who have not donated in a long time
   * and sends them a personalized re-engagement message.
   */
  async sendInactiveDonorNudges() {
    console.log('CRON JOB: Running Inactive Donor Nudge...');
    try {
      // 1. Find donors who are available but haven't donated in over 6 months (180 days).
      const { rows: inactiveDonors } = await db.query(
        `SELECT id, name, phone 
         FROM users
         WHERE 
           user_type = 'donor' AND
           availability_status = 'available' AND
           dnd_status = false AND
           (snooze_until IS NULL OR snooze_until < NOW()) AND
           (last_donation IS NULL OR last_donation < NOW() - INTERVAL '180 days')`
      );

      if (inactiveDonors.length === 0) {
        console.log('CRON JOB: No inactive donors to nudge this week.');
        return;
      }

      console.log(`CRON JOB: Found ${inactiveDonors.length} inactive donors. Sending nudges...`);
      for (const donor of inactiveDonors) {
        const nudgeMessage = `Hi ${donor.name}! We miss you. Patients in your area are still in need of heroes like you. We hope you'll consider donating again soon. Your support makes a huge difference!`;
        await whatsappService.sendTextMessage(donor.phone, nudgeMessage);
        // Add a small delay to avoid spamming the WhatsApp API
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    } catch (error) {
      console.error("CRITICAL ERROR in cron job sendInactiveDonorNudges:", error);
    }
  }
}

export default new EngagementService(); 

```

`backend/src/services/faqService.js`

```javascript
// backend/src/services/faqService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import mlService from './mlService.js';
import { GoogleGenerativeAI } from '@google/generative-ai'; // âœ… ADDED: Import Google AI SDK
import config from '../config/config.js'; // âœ… ADDED: Import config for API key

// âœ… ADDED: Initialize the generative model for dynamic answers
const genAI = new GoogleGenerativeAI(config.geminiApiKey);
const generativeModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" });

const SENSITIVE_KEYWORDS = ['problem', 'pain', 'issue', 'bad', 'reaction', 'scared', 'help me', 'confused', 'afraid'];

class FaqService {
  async handleFaq(query, phone) {
    const disclaimer = "\n\n_Disclaimer: This is automated information. For medical advice, please consult a doctor._";
    try {
      // 1. First, try the RAG system for a precise, pre-written answer.
      const ragResponse = await mlService.client.post('/generate-faq-answer', { query });

      if (ragResponse.data && ragResponse.data.source_found) {
        console.log(`RAG HIT: Found a precise answer for "${query}".`);
        await whatsappService.sendTextMessage(phone, ragResponse.data.answer + disclaimer);
        // We can stop here because we found a perfect answer.
        return;
      }

      // 2. âœ… NEW: If RAG fails, fallback to the generative model with live data.
      console.log(`RAG MISS: Falling back to generative model with live data for "${query}".`);
      
      let contextString = 'You are a helpful and compassionate assistant for BloodBridge AI. Answer the user\'s question concisely.';
      const lowerQuery = query.toLowerCase();

      // Check for keywords and inject live data into the context.
      if (lowerQuery.includes('patient') || lowerQuery.includes('support')) {
        const { rows } = await db.query("SELECT COUNT(*) as count FROM patients WHERE status = 'bridged'");
        const patientCount = rows[0].count;
        if (patientCount > 0) {
          contextString += ` IMPORTANT CONTEXT: We are currently supporting ${patientCount} long-term patients.`;
        }
      } else if (lowerQuery.includes('donor') || lowerQuery.includes('donors')) {
        const { rows } = await db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor' AND availability_status = 'available'");
        const donorCount = rows[0].count;
        if (donorCount > 0) {
          contextString += ` IMPORTANT CONTEXT: We have ${donorCount} active and eligible donors ready to help.`;
        }
      }
      
      // 3. Generate the dynamic answer using the context.
      const prompt = `${contextString}\n\nUser's Question: "${query}"`;
      const result = await generativeModel.generateContent(prompt);
      const response = await result.response;
      const aiText = response.text();

      await whatsappService.sendTextMessage(phone, aiText + disclaimer);

      // 4. Finally, check for sensitive keywords.
     if (SENSITIVE_KEYWORDS.some(keyword => lowerQuery.includes(keyword))) {
        console.log(`Sensitive keyword detected in "${query}". Escalating to admin inbox.`);
        await db.query( "INSERT INTO inbox_messages (user_phone, user_message, reason) VALUES ($1, $2, $3)", [phone, query, 'Sensitive Keyword Detected']);
        const escalationMessage = "It sounds like you might have a specific concern. I have notified an NGO volunteer, and they will contact you on this number shortly.";
        setTimeout(() => { whatsappService.sendTextMessage(phone, escalationMessage); }, 1500);
      }

    } catch (error) {
      console.error("Error calling FAQ service:", error.message);
      const fallbackMessage = "Thank you for your question. An NGO volunteer will get back to you shortly.";
      await whatsappService.sendTextMessage(phone, fallbackMessage);
    }
  }
}

export default new FaqService();

```

`backend/src/services/gamificationService.js`

```javascript
// backend/src/services/gamificationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

const ACHIEVEMENTS = {
  FIRST_REGISTRATION: { name: 'Community Hero', points: 50, emoji: 'â¤ï¸' },
  EMERGENCY_RESPONSE: { name: 'Life Saver', points: 100, emoji: 'ðŸš¨' },
};

class GamificationService {
   async awardPoints(userId, event, userPhone) {
    const achievement = ACHIEVEMENTS[event];
    if (!achievement) return;

    try {
      // Add points to the user's total score.
      const { rows: [user] } = await db.query(
        "UPDATE users SET gamification_points = gamification_points + $1 WHERE id = $2 RETURNING gamification_points",
        [achievement.points, userId]
      );

      if (!user) throw new Error("User not found or update failed.");

      // Log this specific achievement in the achievements table.
      await db.query(
        "INSERT INTO achievements(user_id, badge_type, points_awarded) VALUES($1, $2, $3)",
        [userId, achievement.name, achievement.points]
      );

      // Send a notification to the user.
      const notification = `ðŸ† Achievement Unlocked! ðŸ†\n\nYou've earned the *${achievement.name}* badge ${achievement.emoji} and received *${achievement.points} points*!\n\nYour new total is *${user.gamification_points} points*.`;
      await whatsappService.sendTextMessage(userPhone, notification);
    } catch (error) {
      console.error(`Error in awardPoints for user ${userId}:`, error);
    }
  } 

  /**
   * âœ… UPDATED: Fetches and formats a complete status report for a donor,
   * including their availability status.
   */
  async getDonorStatus(phone) {
    try {
      // Query now includes availability_status and cooldown_until
      const { rows: [user] } = await db.query(
        'SELECT id, name, gamification_points, last_donation, availability_status, cooldown_until FROM users WHERE phone = $1',
        [phone]
      );
      if (!user) {
        return "It looks like you're not registered as a donor yet. Reply with 'I want to register' to get started!";
      }
      
      const { rows: [rankData] } = await db.query(
        'SELECT count(*) FROM users WHERE user_type = \'donor\' AND gamification_points > $1',
        [user.gamification_points]
      );
      const rank = parseInt(rankData.count) + 1;

      // Format the availability status for the user
      let availabilityMessage = 'Available âœ…';
      if (user.availability_status === 'unavailable' && user.cooldown_until) {
        const cooldownDate = new Date(user.cooldown_until).toLocaleDateString('en-IN');
        availabilityMessage = `On Cooldown until ${cooldownDate} â³`;
      } else if (user.availability_status !== 'available') {
        availabilityMessage = 'Not Available âŒ';
      }

      let statusMessage = `*ðŸ“Š Your Donor Dashboard ðŸ“Š*\n\n`;
      statusMessage += `*Name:* ${user.name}\n`;
      statusMessage += `*Status:* ${availabilityMessage}\n`; // Add the status line
      statusMessage += `*Points:* ${user.gamification_points} ðŸ…\n`;
      statusMessage += `*Current Rank:* #${rank} of all our heroes\n`;
      statusMessage += `*Last Donation:* ${user.last_donation ? new Date(user.last_donation).toLocaleDateString('en-IN') : 'N/A'}`;
      
      return statusMessage;
    } catch (error) {
      console.error(`Error in getDonorStatus for phone ${phone}:`, error);
      return "Sorry, I couldn't fetch your status at this time. Please try again later.";
    }
  }

  /**
   * âœ… UPDATED: Fetches the Top 5 donors AND the requesting user's rank.
   */
  async getLeaderboardMessage(phone) {
    try {
      // Query 1: Get the Top 5 donors
      const { rows: topDonors } = await db.query(
        `SELECT name, gamification_points FROM users 
         WHERE user_type = 'donor' AND gamification_points > 0
         ORDER BY gamification_points DESC LIMIT 5`
      );

      if (topDonors.length === 0) {
        return "The leaderboard is empty right now, but the next donation could change that!";
      }

      // Query 2: Get the current user's rank
      const { rows: [userRankData] } = await db.query(
        `SELECT count(*) FROM users WHERE user_type = 'donor' AND gamification_points > (
           SELECT gamification_points FROM users WHERE phone = $1
         )`,
        [phone]
      );
      const userRank = parseInt(userRankData.count) + 1;

      // Format the message
      let leaderboardMessage = "ðŸ† *Top 5 Blood Warriors* ðŸ†\n\n";
      const medals = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', '4.', '5.'];
      topDonors.forEach((donor, index) => {
        leaderboardMessage += `${medals[index]} *${donor.name}* (${donor.gamification_points} points)\n`;
      });
      leaderboardMessage += `\n*Your Rank:* #${userRank}`;

      return leaderboardMessage;
    } catch (error) {
      console.error('Error fetching leaderboard for chatbot:', error);
      return "Sorry, I couldn't fetch the leaderboard right now.";
    }
  }
}

export default new GamificationService();

```

`backend/src/services/geocodingService.js`

```javascript
// backend/src/services/geocodingService.js
import axios from 'axios';

class GeocodingService {
    async getCoords(address, city, pincode) {
        if (!address && !pincode) return null;
        const query = `${address || ''}, ${city || ''}, ${pincode || ''}`;
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
        try {
            const response = await axios.get(url, {
                headers: { 'User-Agent': 'BloodBridgeAI/1.0 (tech@bloodbridge.org)' }
            });
            if (response.data && response.data.length > 0) {
                const { lat, lon } = response.data[0];
                return { latitude: parseFloat(lat), longitude: parseFloat(lon) };
            }
            return null;
        } catch (error) {
            console.error('Error calling Geocoding API:', error.message);
            return null;
        }
    }
}

export default new GeocodingService();

```

`backend/src/services/loggingService.js`

```javascript
// backend/src/services/loggingService.js
import db from '../config/db.js';

class LoggingService {
  /**
   * Logs an incoming message and now includes the user's phone number directly.
   */
  async logIncoming(phone, message) {
    try {
      // Find the user's ID to maintain the relationship, but also store the phone number.
      const { rows: [user] } = await db.query(
        'SELECT id FROM users WHERE phone = $1',
        [phone]
      );
      const userId = user ? user.id : null;

      // Insert the incoming message, user_id, and the user_phone into the table.
      await db.query(
        'INSERT INTO conversations (user_id, user_phone, message) VALUES ($1, $2, $3)',
        [userId, phone, message]
      );
    } catch (error) {
      console.error('Error logging incoming message to DB:', error);
    }
  }

  /**
   * Logs an outgoing message by finding the last message from a specific phone number.
   */
  async logOutgoing(phone, response) {
    try {
      // Find the last conversation from this user's phone number that doesn't have a response yet
      // and update it with the bot's reply. This is more direct than looking up the user ID first.
      await db.query(
        `UPDATE conversations 
         SET response = $1 
         WHERE id = (
           SELECT id FROM conversations 
           WHERE user_phone = $2 AND response IS NULL 
           ORDER BY created_at DESC 
           LIMIT 1
         )`,
        [response, phone]
      );
    } catch (error) {
      console.error('Error logging outgoing message to DB:', error);
    }
  }
}

export default new LoggingService();

```

`backend/src/services/mlService.js`

```javascript
// backend/src/services/mlService.js
import axios from 'axios';
import db from '../config/db.js';
import config from '../config/config.js';

const CACHE_DURATION_HOURS = 6;

class MLService {
    constructor() {
        this.client = axios.create({
            baseURL: config.mlServiceUrl,
            timeout: 8000,
        });
    }

    /**
     * Scores a single donor, using a cached score if available and not stale.
     */
    async scoreSingleDonor(donor) {
        // Check for a fresh score in the cache first.
        const { rows: [cachedData] } = await db.query(
            "SELECT last_ml_score, score_cached_at FROM users WHERE id = $1",
            [donor.id]
        );

        if (cachedData && cachedData.last_ml_score && cachedData.score_cached_at) {
            const cacheAgeHours = (new Date() - new Date(cachedData.score_cached_at)) / (1000 * 60 * 60);
            if (cacheAgeHours < CACHE_DURATION_HOURS) {
                console.log(`CACHE HIT: Using cached score for donor ${donor.id}`);
                return { final_score: cachedData.last_ml_score };
            }
        }

        console.log(`CACHE MISS: Calling ML service for donor ${donor.id}`);
        try {
            // If no fresh cache, call the Python ML service.
            const response = await this.client.post('/score-donor', {
                donor_id: donor.id,
                last_donation_date: donor.last_donation,
                streak_count: donor.streak_count || 0,
                notifications_received: donor.notifications_received || 0,
                donations_confirmed: donor.donations_confirmed || 0
            });
            
            const newScore = response.data.final_score;

            // Update the cache in the database with the new score.
            db.query(
                "UPDATE users SET last_ml_score = $1, score_cached_at = NOW() WHERE id = $2",
                [newScore, donor.id]
            ).catch(err => console.error(`Failed to cache ML score for donor ${donor.id}:`, err));

            return { final_score: newScore };

        } catch (error) {
            console.error(`ðŸ”´ ML Service Error for donor ${donor.id}:`, error.message);
            throw error; // Re-throw the error to be handled by the calling service.
        }
    }
}

export default new MLService();

```

`backend/src/services/patientService.js`

```javascript
// backend/src/services/patientService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class PatientService {
  /**
   * Handles the initial message from a potential patient.
   * Creates a pending record and asks them to opt-in by replying "APPLY".
   */
  async handleNewPatient(params, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingPatient] } = await db.query("SELECT id FROM patients WHERE phone = $1", [sanitizedPhone]);
      if (existingPatient) {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back! Our records show this number is already associated with a patient. An admin will be in touch shortly.`);
        return;
      }

      const { patient_name, city, blood_group } = params;

      // PATH 1: AI extracted details for a one-shot registration (Passes REG-04)
      if (patient_name && city && blood_group) {
        const normalizedBG = normalizeBloodGroup(blood_group);
        await db.query(
          `INSERT INTO patients (name, phone, blood_group, city, status)
           VALUES ($1, $2, $3, $4, 'pending_verification')`,
          [patient_name, sanitizedPhone, normalizedBG, city]
        );
        const finalMessage = `Thank you! We have received the initial information for *${patient_name}*.\n\nAn admin from our team has been notified and will contact you on this number to verify the details.`;
        await whatsappService.sendTextMessage(sanitizedPhone, finalMessage);
      } 
      // PATH 2: Details are missing, fall back to the conversational flow.
      else {
        await db.query(
          `INSERT INTO patients (name, phone, blood_group, city, status)
           VALUES ('Awaiting Input', $1, 'N/A', 'N/A', 'pending_opt_in') ON CONFLICT (phone) DO NOTHING;`,
          [sanitizedPhone]
        );
        await whatsappService.sendTextMessage(sanitizedPhone, `Thank you for reaching out. To begin your application for our Blood Bridge support program, please reply with: *APPLY*`);
      }
    } catch (error) {
      console.error('Error in handleNewPatient:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'Sorry, we encountered an error logging your request.');
    }
  }
  
  
  /**
   * Starts the conversational form after the user replies "APPLY".
   */
  async startApplication(phone) {
      const { rows: [patient] } = await db.query("SELECT id FROM patients WHERE phone = $1 AND status = 'pending_opt_in'", [phone]);
      if (!patient) return false;

      await db.query("UPDATE patients SET status = 'pending_details' WHERE id = $1", [patient.id]);
      await this.continueOnboarding(patient.id, phone);
      return true;
  }

  /**
   * The "state machine" that asks the next question based on what info is missing.
   */
  async continueOnboarding(patientId, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE id = $1", [patientId]);
    if (!patient) return;

    if (patient.name === 'Awaiting Input') {
      await whatsappService.sendTextMessage(phone, "Great! Let's begin.\n\nFirst, what is the patient's full name?");
      return;
    }
    if (patient.blood_group === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Thank you. What is ${patient.name}'s blood group? (e.g., O+, AB-)`);
      return;
    }
    if (patient.city === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Got it. In which city does the patient receive treatment?`);
      return;
    }

    // All details are collected.
    await db.query("UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    const finalMessage = `Thank you! We have all the initial information we need for *${patient.name}*.\n\nAn admin has been notified and will contact you on this number to verify the details.`;
    await whatsappService.sendTextMessage(phone, finalMessage);
  }

  /**
   * Processes a user's reply during the conversational form.
   */
  async processOnboardingReply(message, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE phone = $1 AND status = 'pending_details'", [phone]);
    if (!patient) return false;

    let columnToUpdate = null;
    let valueToUpdate = message;
    
    if (patient.name === 'Awaiting Input') columnToUpdate = 'name';
    else if (patient.blood_group === 'N/A') {
      columnToUpdate = 'blood_group';
      valueToUpdate = normalizeBloodGroup(message);
    } else if (patient.city === 'N/A') columnToUpdate = 'city';
    
    if (columnToUpdate) {
        await db.query(`UPDATE patients SET ${columnToUpdate} = $1 WHERE id = $2`, [valueToUpdate, patient.id]);
        
        // Ask the next question after a short delay
        setTimeout(() => { this.continueOnboarding(patient.id, phone); }, 500);
        return true;
    }
    return false;
  }
}

export default new PatientService();

```

`backend/src/services/registrationService.js`

```javascript
// backend/src/services/registrationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import gamificationService from './gamificationService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';

class RegistrationService {
  /**
   * âœ… REWRITTEN: A single, intelligent function to handle all donor registration.
   */
    async handleNewDonor(params, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingUser] } = await db.query(
        "SELECT id, name, registration_status FROM users WHERE phone = $1", 
        [sanitizedPhone]
      );

      if (existingUser && existingUser.registration_status === 'completed') {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back, ${existingUser.name}! You are already registered.`);
        return;
      }

      const { name, city, blood_group } = params;

      // CASE 1: The AI successfully extracted the details from the user's message.
      if (name && name !== 'Unknown' && city && city !== 'Unknown' && blood_group && blood_group !== 'Unknown') {
        const normalizedBG = normalizeBloodGroup(blood_group);
        
        const { rows: [newUser] } = await db.query(
          `INSERT INTO users(name, city, blood_group, phone, user_type, registration_status, role)
           VALUES($1, $2, $3, $4, 'donor', 'completed', 'Emergency Donor')
           ON CONFLICT (phone) DO UPDATE SET 
             name = EXCLUDED.name, city = EXCLUDED.city, blood_group = EXCLUDED.blood_group, 
             registration_status = 'completed', role = 'Emergency Donor'
           RETURNING *;`,
          [name.trim(), city.trim(), normalizedBG, sanitizedPhone]
        );

        const successMessage = `âœ… Registration Complete!\n\nWelcome, ${newUser.name}! You are now a registered Blood Warrior in ${newUser.city}.`;
        await whatsappService.sendTextMessage(sanitizedPhone, successMessage);
        await gamificationService.awardPoints(newUser.id, 'FIRST_REGISTRATION', sanitizedPhone);

        // âœ… NEW LOGIC: Send the interactive prompt to join a bridge.
        const bridgeQuestion = `Would you like to join a "Blood Bridge"?\n\nThis is a dedicated group of donors who support a specific patient with regular transfusions.`;
        const buttons = [
            { id: `join_bridge_${newUser.id}`, title: "Yes, sign me up!" },
            { id: `decline_bridge_${newUser.id}`, title: "Maybe later" }
        ];
        
        // Use a small delay so messages arrive in the correct order
        setTimeout(() => {
            whatsappService.sendInteractiveMessage(sanitizedPhone, bridgeQuestion, buttons);
        }, 1500); // 1.5 second delay

        return;
      }

      // CASE 2: The AI determined the user wants to register but couldn't find the details.
      const followupMessage = 
        "Great! To get you registered as a donor, please reply with your Name, City, and Blood Group.";
      
      await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);

    } catch (error) {
      console.error('Critical error in handleNewDonor:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'We encountered an error during registration.');
    }
  }
}

export default new RegistrationService();

```

`backend/src/services/responseService.js`

```javascript
// backend/src/services/responseService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateOTP } from '../utils/otpHelper.js';
import gamificationService from './gamificationService.js';
import bridgeService from './bridgeService.js';
import BridgeCoordinationService from './bridgeCoordinationService.js';

class ResponseService {
    /**
     * Handles the donor's initial reply (e.g., "YES 1234").
     * It validates the code and sends back a 6-digit OTP to verify.
     */
    async handleDonorReplyWithShortCode(donorPhone, shortCode) {
        try {
            const { rows: [request] } = await db.query(`SELECT id FROM emergency_requests WHERE short_code = $1 AND status = 'active'`, [shortCode]);
            if (!request) {
                await whatsappService.sendTextMessage(donorPhone, `Sorry, we couldn't find an active request with code ${shortCode}. It may have been fulfilled.`);
                return;
            }

            const { rows: [user] } = await db.query(`SELECT id FROM users WHERE phone = $1`, [donorPhone]);
            if (!user) {
                await whatsappService.sendTextMessage(donorPhone, "We couldn't find your registration. Please register first.");
                return;
            }

            const otp = generateOTP();
            await db.query(
                `INSERT INTO donor_responses (donor_id, request_id, response, otp, otp_expires_at)
                 VALUES ($1, $2, 'pending', $3, NOW() + INTERVAL '10 minutes')
                 ON CONFLICT (donor_id, request_id) DO UPDATE SET response = 'pending', otp = $3, otp_expires_at = NOW() + INTERVAL '10 minutes';`,
                [user.id, request.id, otp]
            );

            const otpMessage = `Thank you for your quick response! To finalize your confirmation, please reply with *only* the following 6-digit code:\n\n*${otp}*`;
            await whatsappService.sendTextMessage(donorPhone, otpMessage);
        } catch (error) {
            console.error('Error in handleDonorReplyWithShortCode:', error);
            await whatsappService.sendTextMessage(donorPhone, "There was a system error processing your reply.");
        }
    }

    /**
     * Verifies the 6-digit OTP and finalizes the donation confirmation.
     * This function uses a database transaction to ensure all updates succeed or none do.
     */

      async handleSimpleDecline(donorPhone) {
    try {
      const { rows: [user] } = await db.query('SELECT id FROM users WHERE phone = $1', [donorPhone]);
      if (!user) return; // User not registered, do nothing.

      // Find the last active request this donor was notified for.
      const { rows: [lastRequest] } = await db.query(
        `SELECT r.id FROM emergency_requests r 
         JOIN donor_responses dr ON r.id = dr.request_id
         WHERE dr.donor_id = $1 AND r.status = 'active' AND dr.response = 'pending'
         ORDER BY dr.created_at DESC LIMIT 1;`,
        [user.id]
      );
      
      if (lastRequest) {
        // Mark their response as 'declined'.
        await db.query(
          "UPDATE donor_responses SET response = 'declined' WHERE donor_id = $1 AND request_id = $2",
          [user.id, lastRequest.id]
        );
        
        await whatsappService.sendTextMessage(donorPhone, "Thank you for letting us know. We will contact the next available donor immediately.");
        
        // Immediately trigger the escalation to the next batch.
        emergencyService.findNextDonorForRequest(lastRequest.id);
      } else {
        await whatsappService.sendTextMessage(donorPhone, "Thank you for your response. There are no active requests pending for you at this moment.");
      }
    } catch (error) {
      console.error("Error handling simple decline:", error);
    }
  }
    // In responseService.js
async verifyOTPAndConfirm(donorPhone, otp) {
    const client = await db.pool.connect();
    try {
        await client.query('BEGIN');

        const { rows: [response] } = await client.query(
            // Add request_type and bridge_id to the SELECT statement
            `SELECT dr.id, dr.request_id, u.name as donor_name, u.id as donor_id, 
                    er.patient_name, er.requested_by_phone, er.request_type, er.bridge_id
             FROM donor_responses dr JOIN users u ON dr.donor_id = u.id JOIN emergency_requests er ON dr.request_id = er.id
             WHERE u.phone = $1 AND dr.otp = $2 AND dr.otp_expires_at > NOW() AND dr.response = 'pending' FOR UPDATE;`,
            [donorPhone, otp]
        );

        if (!response) {
            await whatsappService.sendTextMessage(donorPhone, "Invalid or expired OTP. Please try the 'YES [code]' step again.");
            await client.query('ROLLBACK');
            return;
        }

        // Perform all database updates
        await client.query(`UPDATE users SET last_donation = NOW(), availability_status = 'unavailable', cooldown_until = NOW() + INTERVAL '90 days', donations_confirmed = donations_confirmed + 1, streak_count = streak_count + 1 WHERE id = $1`, [response.donor_id]);
        await client.query("UPDATE donor_responses SET response = 'accepted', confirmed_at = NOW(), otp = NULL WHERE id = $1", [response.id]);
        await client.query("UPDATE emergency_requests SET status = 'fulfilled' WHERE id = $1", [response.request_id]);
        
        // --- NEW LOGIC: ROTATE THE BRIDGE IF APPLICABLE ---
        // We pass the active transaction client to the rotation function
        if (response.request_type === 'bridge' && response.bridge_id) {
            await bridgeCoordinationService.rotateBridge(response.bridge_id, client);
        }
        // --- END NEW LOGIC ---

        await client.query('COMMIT');

        // Send confirmations and award points
        const donorConfirmationMessage = `âœ… Confirmed! Thank you, ${response.donor_name}!\n\nYour donation for *${response.patient_name}* is confirmed. Please coordinate with the hospital. You are a true hero!`;
        await whatsappService.sendTextMessage(donorPhone, donorConfirmationMessage);

        if (response.requested_by_phone && response.requested_by_phone !== 'system') {
            const requesterUpdate = `âœ… Good News! A donor has been confirmed for your request for *${response.patient_name}*.`;
            await whatsappService.sendTextMessage(response.requested_by_phone, requesterUpdate);
        }
        gamificationService.awardPoints(response.donor_id, 'EMERGENCY_RESPONSE', donorPhone);

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("Error verifying OTP:", error);
        await whatsappService.sendTextMessage(donorPhone, "A system error occurred during OTP verification.");
    } finally {
        client.release();
    }
}
}

export default new ResponseService();

```

`backend/src/services/schedulerService.js`

```javascript
// backend/src/services/schedulerService.js
import cron from 'node-cron';
// âœ… FIX: Import the already-created INSTANCES of the services
import engagementService from './engagementService.js';
import bridgeCoordinationService from './bridgeCoordinationService.js';

// âœ… FIX: Use the imported instances directly in these functions
export const triggerEligibilityReminders = () => {
  console.log('MANUAL TRIGGER: Running eligibility reminders...');
  return engagementService.sendEligibilityReminders();
};

export const triggerAutomaticBridgeRequests = () => {
  console.log('MANUAL TRIGGER: Running automatic bridge requests...');
  return bridgeCoordinationService.triggerAutomaticBridgeRequests();
};

export const triggerInactiveDonorNudges = () => {
  console.log('MANUAL TRIGGER: Running inactive donor nudges...');
  return engagementService.sendInactiveDonorNudges();
};

class SchedulerService {
  start() {
    console.log('ðŸ•’ Cron job for eligibility reminders scheduled to run every day at 9:00 AM.');
    cron.schedule('0 9 * * *', triggerEligibilityReminders, { timezone: "Asia/Kolkata" });
    
    console.log('ðŸ•’ Cron job for automatic bridge requests scheduled to run every day at 8:00 AM.');
    cron.schedule('0 8 * * *', triggerAutomaticBridgeRequests, { timezone: "Asia/Kolkata" });
    
    console.log('ðŸ•’ Cron job for inactive donor nudges scheduled to run every Sunday at 10:00 AM.');
    cron.schedule('0 10 * * 0', triggerInactiveDonorNudges, { timezone: "Asia/Kolkata" });
  }
}

export const Scheduler = new SchedulerService();

```

`backend/src/services/whatsappService.js`

```javascript
// backend/src/services/whatsappService.js
import axios from 'axios';
import config from '../config/config.js';
import loggingService from './loggingService.js';

class WhatsAppService {
  constructor() {
    this.token = config.whatsappToken;
    this.phoneNumberId = config.whatsappPhoneNumberId;
    if (!this.token || !this.phoneNumberId) {
      console.warn('WhatsApp token or Phone Number ID are missing. Messages will not be sent.');
    }

    this.client = axios.create({
      baseURL: `https://graph.facebook.com/v18.0/${this.phoneNumberId}`,
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json'
      }
    });
  }
  async sendTextMessage(to, text) {
    if (!this.token) return { success: false, error: "WhatsApp service not configured." };

    const payload = {
      messaging_product: 'whatsapp',
      to: to,
      type: 'text',
      text: { body: text }
    };

    try {
      const response = await this.client.post('/messages', payload);
      
      // âœ… MODIFIED LINE: This now prints the message content to the console.
      console.log(`âœ… Message sent to ${to}: "${text}"`);
      
      await loggingService.logOutgoing(to, text);
      return { success: true, data: response.data };
    } catch (error) {
      console.error(`ðŸ”´ FAILED to send message to ${to}.`);
      if (error.response) {
        console.error(`Error Details: ${error.response.data.error?.message}`);
      }
      return { success: false, error: error.message };
    }
  }

    /**
   * âœ… NEW FUNCTION
   * Sends an interactive message with reply buttons.
   * @param {string} to - The recipient's phone number.
   * @param {string} text - The message body.
   * @param {Array<object>} buttons - Array of button objects, e.g., [{ id: '1', title: 'Yes' }]
   */
  async sendInteractiveMessage(to, text, buttons) {
    if (!this.token) return { success: false, error: "WhatsApp service not configured." };

    const payload = {
      messaging_product: 'whatsapp',
      to: to,
      type: 'interactive',
      interactive: {
        type: 'button',
        body: { text: text },
        action: {
          buttons: buttons.map(btn => ({
            type: 'reply',
            reply: { id: btn.id, title: btn.title }
          }))
        }
      }
    };
    
    try {
      const response = await this.client.post('/messages', payload);
      console.log(`âœ… Interactive message sent to ${to}: "${text}"`);
      await loggingService.logOutgoing(to, text); // Also log this message
      return { success: true, data: response.data };
    } catch (error) {
      console.error(`ðŸ”´ FAILED to send interactive message to ${to}.`);
      if (error.response) {
        console.error(`Error Details: ${error.response.data.error?.message}`);
      }
      return { success: false, error: error.message };
    }
  }

}

export default new WhatsAppService();

```

`backend/src/utils/dataSanitizer.js`

```javascript
// backend/src/utils/dataSanitizer.js
export const normalizeBloodGroup = (group) => {
  if (!group) return 'Unknown';
  
  // âœ… ADD THIS CHECK: Return 'Unknown' immediately if that's the input.
  if (group.toUpperCase() === 'UNKNOWN') {
    return 'Unknown';
  }

  const upperGroup = group.toUpperCase();
  let normalized = upperGroup.replace(/\s/g, '').replace('POSITIVE', '+').replace('NEGATIVE', '-');
  if (normalized.endsWith('POS')) normalized = normalized.replace('POS', '+');
  if (normalized.endsWith('NEG')) normalized = normalized.replace('NEG', '-');
  return normalized.slice(0, 5);
};

```

`backend/src/utils/distanceHelper.js`

```javascript
// backend/src/utils/distanceHelper.js
/**
 * Calculates distance between two lat/lng points in km using the Haversine formula.
 */
export const getDistanceInKm = (lat1, lon1, lat2, lon2) => {
    if ((lat1 == lat2) && (lon1 == lon2)) {
        return 0;
    }
    const R = 6371; // Radius of the earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        0.5 - Math.cos(dLat) / 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        (1 - Math.cos(dLon)) / 2;
    return R * 2 * Math.asin(Math.sqrt(a));
};

```

`backend/src/utils/languageHelper.js`

```javascript
// backend/src/utils/languageHelper.js
import { franc } from 'franc';

// This utility uses a lightweight library to guess the language of a message.
export async function detectLanguage(text) {
  try {
    // franc returns a 3-letter ISO 639-3 code. 'und' means undetermined.
    const langCode = franc(text);
    if (langCode === 'und') {
      return null; // Could not determine language
    }
    // Map common 3-letter codes to 2-letter codes for simplicity
    const langMap = {
        'eng': 'en',
        'hin': 'hi', // Hindi
        'tel': 'te'  // Telugu
    };
    return langMap[langCode] || null;
  } catch (error) {
    console.error("Language detection error:", error);
    return null;
  }
}

```

`backend/src/utils/otpHelper.js`

```javascript
// backend/src/utils/otpHelper.js

/**
 * Generates a 4-digit numeric code for donors to reply with.
 * @returns {string} A 4-digit string.
 */
export const generateShortCode = () => {
  return Math.floor(1000 + Math.random() * 9000).toString();
};

/**
 * Generates a 6-digit numeric OTP for final confirmation.
 * @returns {string} A 6-digit string.
 */
export const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

```

`backend/src/utils/phoneHelper.js`

```javascript
// backend/src/utils/phoneHelper.js
export const normalizePhoneNumber = (phone) => {
  if (!phone || typeof phone !== 'string') return null;
  let digits = phone.replace(/\D/g, '');
  if (digits.startsWith('91') && digits.length === 12) {
    return `+${digits}`;
  } else if (digits.length === 10) {
    return `+91${digits}`;
  }
  return `+${digits}`;
};

```

`backend/src/utils/translationService.js`

```javascript
// backend/src/services/translationService.js
// In a real application, this would connect to a service like Google Translate.
// For this project, we are mocking the translation for a few specific phrases.
class TranslationService {
  async translateToEnglish(text) {
    if (text.includes("à¤•à¥ˆà¤¸à¥‡ à¤ªà¤‚à¤œà¥€à¤•à¤°à¤£") || text.includes("à¤°à¤•à¥à¤¤à¤¦à¤¾à¤¨ à¤•à¥ˆà¤¸à¥‡ à¤•à¤°à¥‡à¤‚")) {
      console.log('Translation Mock: Detected Hindi registration query.');
      return "How can I register to donate blood?";
    }
    if (text.includes("à°¨à°®à±‹à°¦à±") || text.includes("à°Žà°²à°¾ à°¨à°®à±‹à°¦à±")) {
        console.log('Translation Mock: Detected Telugu registration query.');
        return "How can I register to donate blood?";
    }
    // If no match is found, return the original text.
    return text;
  }
}

export default new TranslationService();

```

`code.txt`

```
`admin-dashboard/code2.txt`

```
`code.txt`

```
`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`src/App.jsx`

```javascript
// src/App.jsx

import React, { useState } from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import LoginPage from './LoginPage.jsx';
import Dashboard from './Dashboard.jsx';
import theme from './theme.js';

/**
 * The main App component.
 * It acts as the root of the application, managing authentication state
 * and providing the global MUI theme.
 */
function App() {
  // State to track if the user is logged in. Default is false.
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  // Function to be passed to LoginPage to handle successful login
  const handleLogin = () => {
    setIsLoggedIn(true);
  };

  // Function to be passed to Dashboard to handle logout
  const handleLogout = () => {
    setIsLoggedIn(false);
  };

  return (
    // ThemeProvider applies the custom theme to all descendant components.
    // CssBaseline provides a consistent baseline style across browsers.
    <ThemeProvider theme={theme}>
      <CssBaseline />
      {/* Conditionally render Dashboard or LoginPage based on login state */}
      {isLoggedIn ? (
        <Dashboard onLogout={handleLogout} />
      ) : (
        <LoginPage onLogin={handleLogin} />
      )}
    </ThemeProvider>
  );
}

export default App;

```

`src/Dashboard.jsx`

```javascript
// src/Dashboard.jsx

import React, { useState, useEffect } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Grid, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress,
  Button,
} from "@mui/material";

import { Bloodtype, LocationCity, AddLink, Close } from "@mui/icons-material";

// âœ… Dummy API functions (replace with real API calls)
const fetchPendingPatients = async () =>
  Promise.resolve([
    { id: 1, name: "John Doe", blood_group: "A+", city: "Delhi" },
    { id: 2, name: "Jane Smith", blood_group: "O-", city: "Mumbai" },
  ]);

const fetchActiveEmergencies = async () =>
  Promise.resolve([
    { id: 3, patient_name: "Alex", blood_group: "B+", status: "Urgent" },
    { id: 4, patient_name: "Maria", blood_group: "AB-", status: "Open" },
  ]);

const Dashboard = ({ onLogout }) => {
  const [tabValue, setTabValue] = useState(0);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm")); // <600px
  const isTablet = useMediaQuery(theme.breakpoints.between("sm", "md")); // 600-900px
  const isLaptop = useMediaQuery(theme.breakpoints.between("md", "lg")); // 900-1200px

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      const apiCall = tabValue === 0 ? fetchPendingPatients : fetchActiveEmergencies;
      const result = await apiCall();
      setData(result);
      setLoading(false);
    };
    loadData();
  }, [tabValue]);

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // âœ… Card list for small & medium screens
  const renderCardList = () => (
    <Grid container spacing={2}>
      {data.map((item) => (
        <Grid item xs={12} sm={6} md={4} key={item.id}>
          <Card variant="outlined" sx={{ height: "100%" }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {tabValue === 0 ? item.name : item.patient_name}
              </Typography>
              <Stack direction="column" spacing={1}>
                <Chip
                  icon={<Bloodtype />}
                  label={`Blood Group: ${item.blood_group}`}
                  size="small"
                />
                {tabValue === 0 ? (
                  <Chip
                    icon={<LocationCity />}
                    label={`City: ${item.city}`}
                    size="small"
                  />
                ) : (
                  <Chip label={`Status: ${item.status}`} color="warning" size="small" />
                )}
              </Stack>
            </CardContent>
            <CardActions sx={{ justifyContent: "flex-end" }}>
              {tabValue === 0 ? (
                <Button variant="contained" size="small" startIcon={<AddLink />}>
                  Create Bridge
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="secondary"
                  size="small"
                  startIcon={<Close />}
                >
                  Close Request
                </Button>
              )}
            </CardActions>
          </Card>
        </Grid>
      ))}
    </Grid>
  );

  // âœ… Table for larger screens (Laptop & Desktop)
  const renderTable = () => (
    <TableContainer>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>{tabValue === 0 ? "Name" : "Patient Name"}</TableCell>
            <TableCell>Blood Group</TableCell>
            <TableCell>{tabValue === 0 ? "City" : "Status"}</TableCell>
            <TableCell align="right">Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {data.map((item) => (
            <TableRow hover key={item.id}>
              <TableCell>{tabValue === 0 ? item.name : item.patient_name}</TableCell>
              <TableCell>
                <Chip
                  label={item.blood_group}
                  color="primary"
                  variant="outlined"
                  size="small"
                />
              </TableCell>
              <TableCell>
                {tabValue === 0 ? (
                  item.city
                ) : (
                  <Chip label={item.status} color="warning" size="small" />
                )}
              </TableCell>
              <TableCell align="right">
                {tabValue === 0 ? (
                  <Button variant="contained" size="small" startIcon={<AddLink />}>
                    Create Bridge
                  </Button>
                ) : (
                  <Button
                    variant="contained"
                    color="secondary"
                    size="small"
                    startIcon={<Close />}
                  >
                    Close Request
                  </Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );

// inside src/Dashboard.jsx â€” modify the JSX return where Container is used:

  return (
    <Box
      sx={{
        flexGrow: 1,
        backgroundColor: theme.palette.background.default,
        minHeight: "100vh",
      }}
    >
      {/* AppBar stays full width of viewport */}
      <AppBar position="static" sx={{ boxShadow: 1 }}>
        <Toolbar sx={{ px: { xs: 2, md: 4 } }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            ðŸ©¸ BloodBridge AI
          </Typography>
          <Button color="inherit" onClick={onLogout}>
            Logout
          </Button>
        </Toolbar>
      </AppBar>

      {/* Make container span full width but keep inner content centered with a maxWidth */}
      <Container
        maxWidth={false}
        disableGutters
        sx={{
          px: { xs: 2, md: 4 },
          py: 4,
        }}
      >
        {/* center the page content while allowing it to be fluid on small screens */}
        <Box sx={{ width: "100%", maxWidth: 1100, mx: "auto" }}>
          <Typography variant="h4" gutterBottom>
            Admin Dashboard
          </Typography>

          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 3 }}>
              <Tabs value={tabValue} onChange={handleTabChange}>
                <Tab label="Pending Patients" />
                <Tab label="Active Emergencies" />
              </Tabs>
            </Box>

            {loading ? (
              <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
                <CircularProgress />
              </Box>
            ) : (
              // responsive decision: cards for small/tablet, table for larger screens
              (isMobile || isTablet) ? renderCardList() : renderTable()
            )}
          </Paper>
        </Box>
      </Container>
    </Box>
  );

};

export default Dashboard;

```

`src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`src/LoginPage.jsx`

```javascript
// src/LoginPage.jsx

import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert } from '@mui/material';

/**
 * The LoginPage component.
 * It displays a simple login form and validates the password.
 * On successful validation, it calls the onLogin prop function.
 */
const LoginPage = ({ onLogin }) => {
  // State to hold the password input value
  const [password, setPassword] = useState('');
  // State to hold any login error messages
  const [error, setError] = useState('');

  // Handles the form submission
  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent default form submission behavior

    // Simple validation: check if the password is "admin"
    if (password === 'admin') {
      setError(''); // Clear any previous errors
      onLogin(); // Call the parent component's login handler
    } else {
      // Set an error message for incorrect password
      setError('Incorrect password. Hint: try "admin"');
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h5">
          ðŸ©¸ BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {/* Display an error alert if the error state is not empty */}
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
          >
            Sign In
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;   

```

`src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

// It's good practice to have a minimal CSS reset or base styles.
// You can leave the default index.css or make it an empty file for now.
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

`src/mockApi.js`

```javascript
// src/mockApi.js

/**
 * This file acts as a fake backend API.
 * The functions here simulate network requests by returning a Promise
 * that resolves with mock data after a 500ms delay.
 */

// Mock data for the "Pending Patients" tab
const mockPendingPatients = [
  { "id": "p1", "name": "Aarav Sharma", "blood_group": "A+", "city": "Delhi" },
  { "id": "p2", "name": "Saanvi Gupta", "blood_group": "O-", "city": "Mumbai" },
  { "id": "p3", "name": "Vihaan Reddy", "blood_group": "B+", "city": "Bangalore" },
  { "id": "p4", "name": "Diya Singh", "blood_group": "AB-", "city": "Kolkata" }
];

// Mock data for the "Active Emergencies" tab
const mockActiveEmergencies = [
  { "id": "e1", "patient_name": "Isha Patel", "blood_group": "AB+", "status": "Searching" },
  { "id": "e2", "patient_name": "Rohan Kumar", "blood_group": "O+", "status": "Partially Fulfilled" },
  { "id": "e3", "patient_name": "Ananya Joshi", "blood_group": "A-", "status": "Critical" }
];

/**
 * Fetches a list of pending patients.
 * @returns {Promise<Array<Object>>} A promise that resolves to the patient list.
 */
export const fetchPendingPatients = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockPendingPatients);
    }, 500); // 500ms delay to simulate network latency
  });
};

/**
 * Fetches a list of active emergencies.
 * @returns {Promise<Array<Object>>} A promise that resolves to the emergencies list.
 */
export const fetchActiveEmergencies = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockActiveEmergencies);
    }, 500); // 500ms delay to simulate network latency
  });
};

```

`src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

```

`admin-dashboard/eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`admin-dashboard/index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`admin-dashboard/src/api/apiClient.js`

```javascript
// src/api/apiClient.js
import axios from 'axios';

const BASE = (import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001').replace(/\/$/, '');

const apiClient = axios.create({
  baseURL: BASE,
  headers: { 'Content-Type': 'application/json' },
  timeout: 20000,
});

// simple map to avoid spamming same error repeatedly
const loggedUrls = new Set();

apiClient.interceptors.request.use((config) => {
  const url = config.url || '';
  // attach token for everything except login/register
  if (!url.includes('/login') && !url.includes('/register')) {
    const token = localStorage.getItem('token');
    if (token && typeof token === 'string' && token.split('.').length === 3) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  return config;
});

apiClient.interceptors.response.use(
  (res) => res,
  (err) => {
    const out = {
      url: err.config?.url,
      status: err.response?.status,
      message: err.message,
      data: err.response?.data,
    };

    // Log each failing URL once to reduce noise
    if (!loggedUrls.has(out.url)) {
      loggedUrls.add(out.url);
      console.error('API request failed:', out);
    }

    const normalized = new Error(out.message || 'API error');
    normalized.url = out.url;
    normalized.status = out.status;
    normalized.data = out.data;
    return Promise.reject(normalized);
  }
);

export default apiClient;

```

`admin-dashboard/src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`admin-dashboard/src/App.jsx`

```javascript
// admin-dashboard/src/App.jsx
import React from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import { AuthProvider } from './context/AuthContext.jsx';
import { Routes, Route, Navigate } from 'react-router-dom'; // âœ… IMPORT ROUTER COMPONENTS
import theme from './theme.js';
import LoginPage from './pages/LoginPage.jsx';
import DashboardPage from './pages/Dashboard.jsx';
import { useAuth } from './hooks/useAuth.js';

/**
 * A protected route component. If the user is not logged in,
 * it redirects them to the login page.
 */
const ProtectedRoute = ({ children }) => {
  const { isLoggedIn } = useAuth();
  return isLoggedIn ? children : <Navigate to="/" />;
};

/**
 * The main App component, now with a proper routing structure.
 */
function App() {
  return (
    <AuthProvider>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Routes>
          <Route path="/" element={<LoginPage />} />
          
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute>
                <DashboardPage />
              </ProtectedRoute>
            } 
          />
        </Routes>
      </ThemeProvider>
    </AuthProvider>
  );
}

export default App;

```

`admin-dashboard/src/components/common/ConfirmationDialog.jsx`

```javascript
// src/components/common/ConfirmationDialog.jsx
import React, { useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import {
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from '@mui/material';

/**
 * Reusable confirmation dialog.
 * - Awaits async onConfirm handlers before closing.
 * - Disables buttons while processing to avoid duplicate calls.
 */
const ConfirmationDialog = ({ open, onClose, onConfirm, title, message, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
  const [processing, setProcessing] = useState(false);

  const handleConfirm = useCallback(async () => {
    if (processing) return;
    setProcessing(true);
    try {
      if (typeof onConfirm === 'function') {
        // Call handler and await if it returns a promise
        const result = onConfirm();
        if (result && typeof result.then === 'function') {
          await result;
        }
      }
    } catch (err) {
      // Log â€” parent can set error state if needed
      // Avoid swallowing errors silently in prod; you may surface this to UI
      // eslint-disable-next-line no-console
      console.error('ConfirmationDialog onConfirm error:', err);
    } finally {
      setProcessing(false);
      if (typeof onClose === 'function') onClose();
    }
  }, [onConfirm, onClose, processing]);

  return (
    <Dialog
      open={Boolean(open)}
      onClose={() => {
        if (!processing && typeof onClose === 'function') onClose();
      }}
      aria-labelledby="confirmation-dialog-title"
      aria-describedby="confirmation-dialog-description"
      fullWidth
      maxWidth="xs"
    >
      <DialogTitle id="confirmation-dialog-title">{title}</DialogTitle>
      <DialogContent>
        <DialogContentText id="confirmation-dialog-description">
          {message}
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={() => { if (!processing && typeof onClose === 'function') onClose(); }} disabled={processing}>
          {cancelText}
        </Button>

        <Button
          onClick={handleConfirm}
          color="primary"
          variant="contained"
          autoFocus
          disabled={processing}
        >
          {confirmText}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

ConfirmationDialog.propTypes = {
  open: PropTypes.bool,
  onClose: PropTypes.func,
  onConfirm: PropTypes.func,
  title: PropTypes.string,
  message: PropTypes.string,
  confirmText: PropTypes.string,
  cancelText: PropTypes.string,
};

ConfirmationDialog.defaultProps = {
  open: false,
  onClose: () => {},
  onConfirm: null,
  title: 'Confirm',
  message: '',
  confirmText: 'Confirm',
  cancelText: 'Cancel',
};

export default React.memo(ConfirmationDialog);

```

`admin-dashboard/src/components/dashboard/BloodGroupChart.jsx`

```javascript
// src/components/dashboard/BloodGroupChart.jsx
import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
} from 'recharts';
import { Box, Typography, useTheme } from '@mui/material';

/**
 * A responsive bar chart to display blood group distribution.
 * Expects data shape: [{ blood_group: 'A+', count: 10 }, ...]
 */
const BloodGroupChart = ({ data }) => {
  const theme = useTheme();

  // Defensive: normalize/sort data so chart is stable
  const prepared = useMemo(() => {
    if (!Array.isArray(data)) return [];
    // ensure numeric counts and stable ordering (by blood_group)
    return [...data]
      .map((d) => ({ blood_group: d.blood_group ?? 'Unknown', count: Number(d.count) || 0 }))
      .sort((a, b) => {
        // you can sort by count desc: return b.count - a.count;
        // here we sort by blood_group for predictable axis order
        return a.blood_group.localeCompare(b.blood_group);
      });
  }, [data]);

  if (!prepared || prepared.length === 0) {
    return (
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: 300 }}>
        <Typography color="text.secondary">No chart data available.</Typography>
      </Box>
    );
  }

  return (
    // aria-label helps screen readers understand this visual
    <Box role="img" aria-label="Donor distribution by blood group">
      <ResponsiveContainer width="100%" height={300}>
        <BarChart
          data={prepared}
          margin={{ top: 6, right: 16, left: -12, bottom: 6 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.divider} />
          <XAxis dataKey="blood_group" stroke={theme.palette.text.secondary} />
          <YAxis stroke={theme.palette.text.secondary} allowDecimals={false} />
          <Tooltip
            contentStyle={{
              backgroundColor: theme.palette.background.paper,
              borderColor: theme.palette.divider,
            }}
            formatter={(value) => [value, 'Donors']}
          />
          <Legend />
          <Bar dataKey="count" name="Total Donors" fill={theme.palette.primary.main} />
        </BarChart>
      </ResponsiveContainer>
    </Box>
  );
};

BloodGroupChart.propTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      blood_group: PropTypes.string,
      count: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    })
  ),
};

BloodGroupChart.defaultProps = {
  data: [],
};

export default React.memo(BloodGroupChart);

```

`admin-dashboard/src/components/dashboard/StatCard.jsx`

```javascript
// src/components/dashboard/StatCard.jsx
import React from "react";
import PropTypes from "prop-types";
import { Paper, Box, Typography, Avatar, useTheme } from "@mui/material";

/**
 * A reusable component to display a single dashboard statistic.
 *
 * Props:
 * - icon: React node shown inside the Avatar
 * - title: short label for the stat
 * - value: numeric or string value to display
 * - color: theme token or CSS color for Avatar background (e.g. "primary.main")
 */
const StatCard = ({ icon, title, value, color = "primary.main" }) => {
  const theme = useTheme();

  // Resolve theme token like "primary.main" to an actual color string
  const resolvedColor = (() => {
    if (!color) return undefined;
    // if color contains a dot, treat as theme token
    if (typeof color === "string" && color.includes(".")) {
      const [paletteKey, shade] = color.split(".");
      return theme.palette?.[paletteKey]?.[shade] ?? color;
    }
    return color;
  })();

  // Format numbers nicely (1000 -> 1,000)
  const formattedValue =
    typeof value === "number"
      ? new Intl.NumberFormat().format(value)
      : value ?? "â€”";

  return (
    <Paper
      elevation={3}
      sx={{
        p: 2,
        display: "flex",
        alignItems: "center",
        height: "100%",
      }}
      role="region"
      aria-label={`${title} stat`}
      title={`${title}: ${formattedValue}`}
    >
      <Avatar
        sx={{
          bgcolor: resolvedColor,
          width: 56,
          height: 56,
          mr: 2,
          color: (theme.palette.getContrastText
            ? theme.palette.getContrastText(resolvedColor)
            : "#fff"),
        }}
        aria-hidden="true"
      >
        {icon}
      </Avatar>

      <Box sx={{ minWidth: 0 }}>
        <Typography color="text.secondary" noWrap variant="caption">
          {title}
        </Typography>
        <Typography variant="h5" component="div" fontWeight="bold" noWrap>
          {formattedValue}
        </Typography>
      </Box>
    </Paper>
  );
};

StatCard.propTypes = {
  icon: PropTypes.node,
  title: PropTypes.string.isRequired,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  color: PropTypes.string,
};

StatCard.defaultProps = {
  icon: null,
  value: "0",
  color: "primary.main",
};

export default React.memo(StatCard);

```

`admin-dashboard/src/context/AuthContext.jsx`

```javascript
// src/context/AuthContext.jsx
import React, { createContext, useState } from 'react';

// 1. Create the context
// This object will be used by other components to access the auth state.
export const AuthContext = createContext(null);

// 2. Create the Provider component
// This component will wrap our application and provide the auth state.
export const AuthProvider = ({ children }) => {
  // Initialize the token state by reading from localStorage.
  // This ensures that the user remains logged in even after a page refresh.
  const [token, setToken] = useState(localStorage.getItem('token'));

  // The login function saves the token to both localStorage and the state.
  const login = (newToken) => {
    localStorage.setItem('token', newToken);
    setToken(newToken);
  };

  // The logout function removes the token from localStorage and the state.
  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
  };

  // 3. Define the value to be provided by the context
  // We derive `isLoggedIn` directly from the presence of a token.
  const value = {
    token,
    isLoggedIn: !!token,
    login,
    logout,
  };

  // 4. Return the provider with the value, wrapping any child components.
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

```

`admin-dashboard/src/hooks/useAuth.js`

```javascript
// src/hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext.jsx';

/**
 * A custom hook for accessing the AuthContext.
 * This simplifies the process in any component that needs auth data,
 * as we can just call `useAuth()` instead of `useContext(AuthContext)`.
 */
export const useAuth = () => {
  return useContext(AuthContext);
};

```

`admin-dashboard/src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`admin-dashboard/src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom'; // <-- 1. IMPORT THE ROUTER
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    {/* 2. WRAP YOUR APP WITH THE ROUTER */}
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

```

`admin-dashboard/src/pages/Dashboard.jsx`

```javascript
// admin-dashboard/src/pages/Dashboard.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress, Button, Alert,
  Badge, Grid, Snackbar
} from "@mui/material";
import {
  Bloodtype, LocationCity, AddLink, Close, Logout,
  PeopleAlt, Favorite, Healing, Warning,
  Dashboard as DashboardIcon, Inbox as InboxIcon,
  People as PeopleIcon, Emergency as EmergencyIcon,
  Hub as HubIcon, ShowChart as ShowChartIcon,
  CheckCircleOutline as CheckCircleOutlineIcon,
  NotificationImportant as EscalationIcon,
  AddCircleOutline as AddCircleOutlineIcon
} from "@mui/icons-material";
import { createClient } from '@supabase/supabase-js';

import { useAuth } from "../hooks/useAuth.js";
import apiClient from "../api/apiClient.js";
import StatCard from "../components/dashboard/StatCard.jsx";
import BloodGroupChart from "../components/dashboard/BloodGroupChart.jsx";
import ConfirmationDialog from "../components/common/ConfirmationDialog.jsx";

// --- INITIALIZE SUPABASE CLIENT ---
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseAnonKey);

const normalizeList = (res) => {
  if (!res) return [];
  if (Array.isArray(res)) return res;
  const d = res.data;
  if (Array.isArray(d)) return d;
  if (d && Array.isArray(d.data)) return d.data;
  return [];
};

const TabPanel = ({ children, value, index, ...other }) => (
  <div role="tabpanel" hidden={value !== index} {...other}>
    {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
  </div>
);

const getDueDateInfo = (dueDate) => {
  if (!dueDate) return { text: 'N/A', color: 'text.secondary', days: Infinity };
  const today = new Date();
  const nextDate = new Date(dueDate);
  today.setHours(0, 0, 0, 0);
  nextDate.setHours(0, 0, 0, 0);
  const diffTime = nextDate - today;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return { text: `OVERDUE by ${Math.abs(diffDays)} days`, color: 'error.main', days: diffDays };
  if (diffDays === 0) return { text: 'DUE TODAY', color: 'error.main', days: diffDays };
  if (diffDays <= 7) return { text: `Due in ${diffDays} days`, color: 'warning.main', days: diffDays };
  return { text: `Due in ${diffDays} days`, color: 'text.primary', days: diffDays };
};

const DashboardPage = () => {
  const { logout } = useAuth();
  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("md"));
  const [currentTab, setCurrentTab] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [snackbar, setSnackbar] = useState({ open: false, message: '' });
  const [dialogConfig, setDialogConfig] = useState({ open: false, title: '', message: '', onConfirm: () => {} });

  const [stats, setStats] = useState({});
  const [bloodGroupData, setBloodGroupData] = useState([]);
  const [inboxMessages, setInboxMessages] = useState([]);
  const [pendingPatients, setPendingPatients] = useState([]);
  const [monitoredPatients, setMonitoredPatients] = useState([]);
  const [emergencies, setEmergencies] = useState([]);
  const [bridges, setBridges] = useState([]);
  const [leaderboard, setLeaderboard] = useState([]);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      const [
        statsRes, 
        bloodGroupRes, 
        patientsRes, 
        emergenciesRes, 
        bridgesRes, 
        inboxRes,
        leaderboardRes
      ] = await Promise.all([
        apiClient.get('/api/admin/stats'),
        apiClient.get('/api/admin/stats/blood-groups'),
        apiClient.get('/api/admin/patients'),
        apiClient.get('/api/admin/emergencies'),
        apiClient.get('/api/admin/bridges'),
        apiClient.get('/api/admin/inbox'),
        apiClient.get('/api/admin/leaderboard')
      ]);

      setStats(statsRes.data || {});
      setBloodGroupData(bloodGroupRes.data || []);
      setEmergencies(normalizeList(emergenciesRes));
      setBridges(normalizeList(bridgesRes));
      setInboxMessages(normalizeList(inboxRes));
      setLeaderboard(normalizeList(leaderboardRes));

      const allPatients = normalizeList(patientsRes);
      const PENDING_STATUSES = ['pending', 'pending_opt_in', 'pending_details', 'pending_verification'];
      setPendingPatients(allPatients.filter(p => PENDING_STATUSES.includes(p.status)));
      
      const bridged = allPatients.filter(p => p.status === 'bridged');
      bridged.sort((a, b) => getDueDateInfo(a.next_due_date).days - getDueDateInfo(b.next_due_date).days);
      setMonitoredPatients(bridged);
    } catch (err) {
      setError('Failed to fetch data. Your session may have expired.');
      if (err.response && err.response.status === 401) logout();
    } finally {
      setLoading(false);
    }
  }, [logout]);

  useEffect(() => {
    fetchData();
    if (supabaseUrl && supabaseAnonKey) {
      const channel = supabase.channel('public-db-changes')
        .on('postgres_changes', { event: '*', schema: 'public' }, () => {
          console.log('Real-time change detected, refetching data...');
          fetchData();
        })
        .subscribe();
      
      return () => { supabase.removeChannel(channel); };
    }
  }, [fetchData]);

  const handleApiAction = async (action, successMessage) => {
    try {
      const response = await action();
      setSnackbar({ open: true, message: response.data.message || successMessage });
      fetchData();
    } catch (err) {
      setSnackbar({ open: true, message: err.response?.data?.error || 'Action failed!' });
    }
    setDialogConfig({ ...dialogConfig, open: false });
  };

  const confirmAction = (title, message, action, successMessage) => {
    setDialogConfig({ open: true, title, message, onConfirm: () => handleApiAction(action, successMessage) });
  };

  const renderLeaderboard = () => {
    if (loading && leaderboard.length === 0) {
      return <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}><CircularProgress /></Box>;
    }
    if (!leaderboard || leaderboard.length === 0) {
      return <Typography sx={{ p: 3, textAlign: 'center', height: '100%' }}>No donor data for leaderboard.</Typography>;
    }
    return (
      <TableContainer>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>Rank</TableCell>
              <TableCell>Name</TableCell>
              <TableCell align="right">Points</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {leaderboard.map((donor, index) => (
              <TableRow key={index}>
                <TableCell>{index + 1}</TableCell>
                <TableCell>{donor.name}</TableCell>
                <TableCell align="right">{donor.gamification_points}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  const renderDuePatientsAlert = () => {
    const duePatients = monitoredPatients.filter(p => getDueDateInfo(p.next_due_date).days <= 7);
    
    if (duePatients.length === 0) return null;
    
    return (
      <Paper elevation={3} sx={{ p: { xs: 2, md: 3 }, mb: 4, border: 2, borderColor: 'error.main' }}>
        <Typography variant="h6" color="error.main" gutterBottom>
          Action Required: Patients Due for Transfusion
        </Typography>
        <TableContainer>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Name</TableCell>
                <TableCell>Due Date</TableCell>
                <TableCell>Status</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {duePatients.map((p) => {
                const dueInfo = getDueDateInfo(p.next_due_date);
                return (
                  <TableRow key={p.id} hover>
                    <TableCell>{p.name}</TableCell>
                    <TableCell>{p.next_due_date ? new Date(p.next_due_date).toLocaleDateString() : 'N/A'}</TableCell>
                    <TableCell sx={{ color: dueInfo.color }}>{dueInfo.text}</TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    );
  };

  const renderTabContent = () => {
    switch (currentTab) {
      case 0: // Analytics
        return (
          <Grid container spacing={3} sx={{ mt: 1 }}>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<PeopleIcon />} title="Total Donors" value={stats.total_donors} />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Favorite />} title="Active & Eligible" value={stats.active_donors} color="success.main" />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Warning />} title="Patients Due Soon" value={stats.patients_at_risk} color="warning.main" />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Healing />} title="Pending Patients" value={stats.pending_patients} color="info.main" />
            </Grid>
            
            <Grid item sx={{ width: { xs: '100%', lg: '66%' } }}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>Donor Blood Groups</Typography>
                <Box sx={{ height: 320 }}>
                  <BloodGroupChart data={bloodGroupData} />
                </Box>
              </Paper>
            </Grid>
            <Grid item sx={{ width: { xs: '100%', lg: '34%' } }}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>Top Donors Leaderboard</Typography>
                {renderLeaderboard()}
              </Paper>
            </Grid>
          </Grid>
        );
      
      case 1: // Inbox
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>User Phone</TableCell>
                  <TableCell>Message</TableCell>
                  <TableCell>Reason</TableCell>
                  <TableCell align="right">Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {inboxMessages.map((msg) => (
                  <TableRow key={msg.id}>
                    <TableCell>{msg.user_phone}</TableCell>
                    <TableCell>{msg.user_message}</TableCell>
                    <TableCell><Chip label={msg.reason} color="warning" size="small" /></TableCell>
                    <TableCell align="right">
                      <Button 
                        onClick={() => confirmAction(
                          'Confirm Resolution', 
                          `Mark message from ${msg.user_phone} as resolved?`, 
                          () => apiClient.post(`/api/admin/inbox/${msg.id}/resolve`), 
                          'Message Resolved!'
                        )} 
                        startIcon={<CheckCircleOutlineIcon />}
                      >
                        Resolve
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 2: // Pending Patients
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Name</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {pendingPatients.map((p) => (
                  <TableRow key={p.id}>
                    <TableCell>{p.name}</TableCell>
                    <TableCell><Chip label={p.status} size="small" /></TableCell>
                    <TableCell>
                      <Button 
                        onClick={() => confirmAction(
                          'Confirm Bridge Creation', 
                          `Create a bridge for ${p.name}?`, 
                          () => apiClient.post(`/api/admin/patients/${p.id}/create-bridge`), 
                          'Bridge Created!'
                        )} 
                        startIcon={<AddCircleOutlineIcon />}
                      >
                        Create Bridge
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 3: // Patient Monitor
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Patient Name</TableCell>
                  <TableCell>Next Transfusion</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {monitoredPatients.map((p) => { 
                  const ddi = getDueDateInfo(p.next_due_date); 
                  return (
                    <TableRow key={p.id} sx={{ backgroundColor: ddi.days < 0 ? 'rgba(255, 0, 0, 0.1)' : 'transparent' }}>
                      <TableCell>{p.name}</TableCell>
                      <TableCell sx={{ color: ddi.color }}>{ddi.text}</TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 4: // Active Emergencies
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Patient</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {emergencies.map((req) => (
                  <TableRow key={req.id}>
                    <TableCell>{req.patient_name}</TableCell>
                    <TableCell>{req.status}</TableCell>
                    <TableCell>
                      <Stack direction="row" spacing={1}>
                        <Button 
                          size="small" 
                          onClick={() => confirmAction(
                            'Confirm Closure', 
                            `Close request for ${req.patient_name}?`, 
                            () => apiClient.post(`/api/admin/emergencies/${req.id}/close`), 
                            'Request Closed!'
                          )} 
                          startIcon={<Close />}
                        >
                          Close
                        </Button>
                        <Button 
                          size="small" 
                          color="warning" 
                          onClick={() => confirmAction(
                            'Confirm Escalation', 
                            `Escalate request for ${req.patient_name}?`, 
                            () => apiClient.post(`/api/admin/emergencies/${req.id}/escalate`), 
                            'Escalation Initiated!'
                          )} 
                          startIcon={<EscalationIcon />}
                        >
                          Escalate
                        </Button>
                      </Stack>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 5: // Bridge Monitor
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Bridge Name</TableCell>
                  <TableCell>Patient</TableCell>
                  <TableCell>Members</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {bridges.map((b) => (
                  <TableRow key={b.id}>
                    <TableCell>{b.name}</TableCell>
                    <TableCell>{b.patient_name}</TableCell>
                    <TableCell>{b.member_count}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      default:
        return <div>Select a tab</div>;
    }
  };

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', bgcolor: 'background.default' }}>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>ðŸ©¸ BloodBridge AI Dashboard</Typography>
          <Button color="inherit" onClick={logout} startIcon={<Logout />}>Logout</Button>
        </Toolbar>
      </AppBar>

      <Container maxWidth="xl" sx={{ mt: 2, mb: 4, flexGrow: 1, overflowY: 'auto' }}>
        {renderDuePatientsAlert()}
        
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <Paper sx={{ p: 2 }}>
          <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
            <Tabs 
              value={currentTab} 
              onChange={(e, val) => setCurrentTab(val)} 
              variant="scrollable" 
              scrollButtons="auto"
            >
              <Tab icon={<ShowChartIcon />} label="Analytics" />
              <Tab icon={<InboxIcon />} label={
                <Badge badgeContent={inboxMessages.length} color="error">
                  Inbox
                </Badge>
              } />
              <Tab icon={<PeopleIcon />} label={
                <Badge badgeContent={pendingPatients.length} color="primary">
                  Pending Patients
                </Badge>
              } />
              <Tab icon={<PeopleIcon />} label="Patient Monitor" />
              <Tab icon={<EmergencyIcon />} label="Active Emergencies" />
              <Tab icon={<HubIcon />} label="Bridge Monitor" />
            </Tabs>
          </Box>

          {loading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
              <CircularProgress />
            </Box>
          ) : (
            renderTabContent()
          )}
        </Paper>
      </Container>

      <ConfirmationDialog 
        {...dialogConfig} 
        onClose={() => setDialogConfig({ ...dialogConfig, open: false })} 
      />
      
      <Snackbar 
        open={snackbar.open} 
        autoHideDuration={6000} 
        onClose={() => setSnackbar({ ...snackbar, open: false })} 
        message={snackbar.message} 
      />
    </Box>
  );
};

export default DashboardPage;

```

`admin-dashboard/src/pages/LoginPage.jsx`

```javascript
// admin-dashboard/src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth.js';
import apiClient from '../api/apiClient.js';

const LoginPage = () => {
  const { login } = useAuth();
  const navigate = useNavigate();

  // --- MODIFICATION: Hardcode the phone number for the demo user ---
  // We no longer need a state for the phone number.
  const phone = '+918000000000';
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleLogin = async (event) => {
    event.preventDefault();
    setError('');
    
    // Simple password validation
    if (!password) {
        setError('Password is required.');
        return;
    }

    setLoading(true);
    try {
      // The component now sends the hardcoded phone number and the entered password.
      console.log('Attempting login with:', { phone, password });
      const response = await apiClient.post('/api/admin/login', { phone, password });

      if (response.data?.token) {
        console.log('Login successful, token:', response.data.token);
        // Using localStorage to persist the token across browser sessions.
        localStorage.setItem('token', response.data.token);
        login(response.data.token);
        navigate('/dashboard');
      } else {
        // This case is unlikely if the backend is structured correctly, but good to have.
        setError('Login failed: No token received from server.');
      }
    } catch (err) {
      console.error('Login error:', {
        message: err.message,
        status: err.response?.status,
        data: err.response?.data,
      });

      // Provide more specific feedback to the user.
      if (err.response?.status === 401) {
        setError('Invalid password. Hint: try "admin123"');
      } else if (err.code === 'ECONNABORTED' || !err.response) {
        setError('Cannot connect to the server. Please ensure it is running.');
      } else {
        setError(err.response?.data?.message || 'An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box sx={{ mt: 8, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Typography component="h1" variant="h5">
          ðŸ©¸ BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleLogin} sx={{ mt: 3, width: '100%' }}>
          {/* --- MODIFICATION: The phone number input field has been removed --- */}
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            disabled={loading}
            sx={{ mt: 3, mb: 2 }}
          >
            {loading ? <CircularProgress size={24} color="inherit" /> : 'Sign In'}
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;

```

`admin-dashboard/src/pages/RegisterPage.jsx`

```javascript


```

`admin-dashboard/src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`admin-dashboard/vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

`backend/.env`

```
# ----------------------------------
# SERVER CONFIGURATION
# ----------------------------------
PORT=3001

# ----------------------------------
# SECURITY
# ----------------------------------
# Generate a new random string from https://www.uuidgenerator.net/ and paste it here
JWT_SECRET="eb4db4a414678902613083784a04ec9de45570856d8ced1dbe6fdd4a545ff715"

# ----------------------------------
# DATABASE (CONNECTION POOLER)
# ----------------------------------
# Replace the ENTIRE line below with your Connection Pooler URI from Supabase
DATABASE_URL="postgresql://postgres.psussvygzgzkkwdjqbwp:asdfusahdfuu3842r7gdsfh@aws-1-ap-southeast-1.pooler.supabase.com:6543/postgres"

# ----------------------------------
# THIRD-PARTY APIs
# ----------------------------------
# Paste your Gemini API key from Google AI Studio
GEMINI_API_KEY="AIzaSyBrkoxm2wP2Wd__AGVspY9bP9G_DwZxGOg"

# For the local Python service
ML_SERVICE_URL="http://localhost:8000"

# ----------------------------------
# WHATSAPP (FROM YOUR META APP)
# ----------------------------------
# Paste your own credentials from your Meta for Developers App
WHATSAPP_TOKEN="EAAY5EGe8MHkBPSNKbGVvTgOUrnZBZAGOP6v7b8rz7M9iVoQsV4AicoQKInVE6zu7Ou5dSXaWhHvxJJroXSaknHBt3Jtsqd4dw3hOZABmPCVDRSPT3cJJML1U3CEBlXfgZB7aF2NG6zoY1HFqCKFYgEPEyQaFo2LacMRyWqV1KiEIWgJbaYRXsiFfYsZCwuEC7ALLGkBEZB1LA1aZB96obPX23B4JYBOvCLcGmQZBYUa5KCkZD"
WHATSAPP_PHONE_NUMBER_ID="729824143554882"
WHATSAPP_APP_SECRET="e94bd0c1a5619ee68b105222b0185dc6"
WHATSAPP_VERIFY_TOKEN="inquilab_bloodai-123-2025-hackathon"

# ----------------------------------
# DEMO & ADMIN
# ----------------------------------
ADMIN_DEMO_PHONE="+918000000000"
DEMO_VERIFIED_PHONE_NUMBERS=""


```

`backend/server.js`

```javascript
// backend/server.js

// Import required dependencies
import express from 'express'; // Express framework for building the server
import cors from 'cors'; // Middleware for enabling CORS
import morgan from 'morgan'; // Middleware for request logging
import config from './src/config/config.js'; // Configuration settings
import adminRoutes from './src/routes/adminRoutes.js'; // Admin dashboard routes
import { verifyWebhook } from './src/middleware/verifyWebhook.js'; // Webhook signature verification
import webhookController from './src/controllers/webhookController.js'; // Webhook handling controller
import BridgeCoordinationService from './src/services/bridgeCoordinationService.js';

// --- PHASE 1: PREDICTIVE ENGAGEMENT ---
import cron from 'node-cron'; // Import the cron scheduler library
import EngagementService from './src/services/engagementService.js'; // Import our new engagement service
// --- END PHASE 1 ---

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3001; // Use environment PORT or default to 3001

// Middleware setup
app.use(cors()); // Enable CORS for all routes
app.use(morgan('tiny')); // Log HTTP requests in 'tiny' format

// API and Health Routes
app.get('/health', (req, res) => {
  // Health check endpoint to verify server status
  res.status(200).json({ status: 'healthy', now: new Date().toISOString() });
});

// Admin routes with JSON body parser
app.use('/api/admin', express.json({ limit: '1mb' }), adminRoutes);

// Webhook Routes
app.get('/webhook', webhookController.verifyToken); // Handle Meta webhook verification (GET)

app.post(
  '/webhook',
  express.json({
    verify: (req, res, buf) => {
req.rawBody = buf.toString();     }
  }),
  verifyWebhook, // This middleware will now use req.rawBody
  webhookController.handleMessage // This controller will use the parsed req.body
);

// Global Error Handling
app.use((err, req, res, next) => {
  // Handle errors from middleware or routes
  console.error('[ERROR HANDLER]', err.stack);
  res.status(500).json({ message: 'An internal server error occurred.' });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason) => {
  console.error('Unhandled Rejection:', reason);
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
});


// --- PHASE 1: PREDICTIVE ENGAGEMENT SCHEDULER ---
// This task is scheduled to run at 9:00 AM every day in the Asia/Kolkata timezone.
// It will automatically find donors who are now eligible to donate again and send them a reminder.
console.log('ðŸ•’ Cron job for eligibility reminders scheduled to run every day at 9:00 AM.');
cron.schedule('0 9 * * *', () => {
  console.log('â° It is 9:00 AM. Triggering the eligibility reminder cron job...');
  // We create a new instance to ensure it's a fresh run
  const engagementService = new EngagementService();
  engagementService.sendEligibilityReminders();
}, {
  scheduled: true,
  timezone: "Asia/Kolkata" // IMPORTANT: Set to your target timezone
});

console.log('ðŸ•’ Cron job for automatic bridge requests scheduled to run every day at 8:00 AM.');
cron.schedule('0 8 * * *', () => {
  console.log('â° It is 8:00 AM. Triggering automatic bridge requests...');
  const bridgeService = new BridgeCoordinationService();
  bridgeService.triggerAutomaticBridgeRequests();
}, {
  scheduled: true,
  timezone: "Asia/Kolkata"
});

// '0 10 * * 0' means at minute 0, hour 10, on day-of-week 0 (Sunday).
console.log('ðŸ•’ Cron job for inactive donor nudges scheduled to run every Sunday at 10:00 AM.');
cron.schedule('0 10 * * 0', () => {
    console.log('â° It is Sunday 10:00 AM. Triggering inactive donor nudge...');
    const engagementService = new EngagementService();
    engagementService.sendInactiveDonorNudges();
}, {
    scheduled: true,
    timezone: "Asia/Kolkata"
});
// --- END PHASE 1 ---


// Start the server
app.listen(PORT, () => {
  console.log(`âœ… BloodBridge AI backend is running on port ${PORT}`);
});

```

`backend/src/config/config.js`

```javascript
// backend/src/config/config.js
import 'dotenv/config'; // Loads variables from .env into process.env

// This object maps environment variables to a clean, accessible config object.
const config = {
    port: process.env.PORT,
    jwtSecret: process.env.JWT_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    geminiApiKey: process.env.GEMINI_API_KEY,
    mlServiceUrl: process.env.ML_SERVICE_URL,
    whatsappToken: process.env.WHATSAPP_TOKEN,
    whatsappPhoneNumberId: process.env.WHATSAPP_PHONE_NUMBER_ID,
    whatsappAppSecret: process.env.WHATSAPP_APP_SECRET,
    whatsappVerifyToken: process.env.WHATSAPP_VERIFY_TOKEN,
    adminDemoPhone: process.env.ADMIN_DEMO_PHONE,
    demoVerifiedPhoneNumbers: process.env.DEMO_VERIFIED_PHONE_NUMBERS
};

// This validation step ensures the application fails fast if critical secrets are missing.
// It's a crucial security and stability feature.
const requiredConfig = ['port', 'jwtSecret', 'databaseUrl'];
const missingConfig = requiredConfig.filter(key => !config[key]);

if (missingConfig.length > 0) {
    console.error(`ðŸ”´ FATAL ERROR: Missing required environment variables: ${missingConfig.join(', ')}`);
    // Exit the application with an error code.
    process.exit(1);
}

export default config;

```

`backend/src/config/db.js`

```javascript
// backend/src/config/db.js
import { Pool } from 'pg';
import config from './config.js';

/**
 * Creates a new connection pool.
 * The pool manages multiple client connections to the database,
 * reusing them to improve performance and stability.
 */
const pool = new Pool({
  connectionString: config.databaseUrl,
});

/**
 * A helper function to execute a simple query.
 * @param {string} text - The SQL query string.
 * @param {Array} params - The parameters to pass to the query.
 * @returns {Promise<QueryResult>} The result from the database.
 */
const query = (text, params) => pool.query(text, params);

// We export the entire pool so we can use it for transactions later,
// and the query function for convenience.
const db = {
  query,
  pool,
};

export default db;

```

`backend/src/controllers/adminController.js`

```javascript
// backend/src/controllers/adminController.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import db from '../config/db.js';
import bridgeService from '../services/bridgeService.js';
import bridgeCoordinationService from '../services/bridgeCoordinationService.js'; 
import emergencyService from '../services/emergencyService.js';

/**
 * Admin Login
 */
export const login = async (req, res) => {
  const { phone, password } = req.body;
  if (!phone || !password) {
    return res.status(400).json({ message: 'Phone and password are required' });
  }
  try {
    // Demo admin login (for prototype)
    if (phone === config.adminDemoPhone && password === 'admin123') {
      const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
      console.log(`Login successful for demo admin: ${phone}`);
      return res.json({ token });
    }
    // In a real app, you would have hashed password validation here
    const { rows } = await db.query(
      'SELECT * FROM users WHERE phone = $1 AND role = $2',
      [phone, 'Admin']
    );
    if (rows.length === 0 || rows[0].password !== password) {
      console.warn('Login failed for phone:', phone);
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
    console.log(`Login successful for user: ${phone}`);
    return res.json({ token });

  } catch (err) {
    console.error('Login error:', { error: err.message, phone });
    return res.status(500).json({ message: 'Server error during login' });
  }
};

/**
 * Create a Blood Bridge for a Patient
 */
export const createBridgeForPatient = async (req, res) => {
  const { patientId } = req.params;
  try {
    const { rows: [patient] } = await db.query(
      'SELECT * FROM patients WHERE id = $1',
      [patientId]
    );

    if (!patient) {
      return res.status(404).json({ message: 'Patient not found' });
    }
    if (patient.status === 'bridged') {
      return res.status(400).json({ message: 'Patient already has a bridge.' });
    }

    const { rows: [bridge] } = await db.query(
      'INSERT INTO blood_bridges (patient_id, name, blood_group, city) VALUES ($1, $2, $3, $4) RETURNING id',
      [patient.id, `${patient.name}'s Bridge`, patient.blood_group, patient.city]
    );

    const result = await bridgeService.populateNewBridge(
      bridge.id,
      patient.city,
      patient.blood_group,
      patient.pincode
    );

    await db.query(
      "UPDATE patients SET status = 'bridged' WHERE id = $1",
      [patientId]
    );
    console.log(`ADMIN ACTION: Created and populated Bridge ${bridge.id} with ${result.count} members.`);
    res.json({
      success: true,
      message: `Blood Bridge created and populated with ${result.count} top donors.`
    });
  } catch (error) {
    console.error('Error creating bridge for patient:', error);
    await db.query( "UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    res.status(500).json({ error: 'Failed to create and populate bridge.' });
  }
};

/**
 * Close Emergency Request
 */
export const closeEmergency = async (req, res) => {
  const { requestId } = req.params;
  try {
    const { rowCount } = await db.query(
      "UPDATE emergency_requests SET status = 'closed' WHERE id = $1 AND status = 'active'",
      [requestId]
    );
    if (rowCount === 0) {
      return res.status(404).json({ message: "Active request not found or already closed."})
    }
    console.log(`ADMIN ACTION: Closed emergency request ${requestId}`);
    res.json({ success: true, message: 'Request successfully closed.' });
  } catch (error) {
    console.error(`Error closing emergency ${requestId}:`, error);
    res.status(500).json({ error: 'Failed to close request.' });
  }
};

/**
 * Triggers a transfusion request for a patient in a Blood Bridge.requestBridgeTransfusion
 */
export const requestBridgeTransfusion = async (req, res) => {
  const { bridgeId } = req.params;
  try {
    // Use the imported instance directly
    const result = await bridgeCoordinationService.requestTransfusion(bridgeId);
  // --- END OF FIX ---
    console.log(`ADMIN ACTION: Triggered transfusion request for bridge ${bridgeId}`);
    res.json(result);
  } catch (error) {
    console.error(`Error requesting bridge transfusion for ${bridgeId}:`, error);
    res.status(500).json({ error: error.message || 'Failed to send bridge request.' });
  }
};

/**
 * Fetches the four main statistics for the StatCards on the dashboard.
 */
export const getDashboardStats = async (req, res) => {
  try {
    const [
      { rows: [totalDonors] },
      { rows: [activeDonors] },
      { rows: [pendingPatients] },
      { rows: [atRisk] }
    ] = await Promise.all([
      db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor'"),
      db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor' AND availability_status = 'available'"),
      db.query("SELECT COUNT(*) as count FROM patients WHERE status = 'pending_verification'"),
      db.query("SELECT COUNT(*) as count FROM emergency_requests WHERE status = 'active'")
    ]);
    
    res.json({
      total_donors: parseInt(totalDonors.count, 10),
      active_donors: parseInt(activeDonors.count, 10),
      pending_patients: parseInt(pendingPatients.count, 10),
      patients_at_risk: parseInt(atRisk.count, 10),
    });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ error: 'Failed to fetch dashboard stats.' });
  }
};

/**
 * Fetches the count of donors for each blood group for the chart.
 */
export const getBloodGroupStats = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT blood_group, COUNT(*) as count 
       FROM users 
       WHERE user_type = 'donor' AND blood_group IS NOT NULL AND blood_group != 'Unknown'
       GROUP BY blood_group 
       ORDER BY blood_group`
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching blood group stats:', error);
    res.status(500).json({ error: 'Failed to fetch blood group stats.' });
  }
};

/**
 * Fetches patients with 'pending_verification' status for the Patients tab.
 */

export const getPatients = async (req, res) => {
  try {
    // --- THIS IS THE CORRECTED QUERY ---
    // Instead of a risky subquery, we use a LEFT JOIN. This is safer and more efficient.
    // It correctly handles the case where a patient has no bridge yet (member_count will be 0).
    const query = `
      SELECT 
        p.id, p.name, p.phone, p.blood_group, p.city, p.status, p.condition,
        p.last_transfusion_date, p.frequency_in_days,
        p.last_transfusion_date + (p.frequency_in_days || ' days')::interval AS next_due_date,
        COUNT(bm.id) as bridge_member_count
      FROM 
        patients p
      LEFT JOIN 
        blood_bridges bb ON p.id = bb.patient_id
      LEFT JOIN 
        bridge_members bm ON bb.id = bm.bridge_id
      GROUP BY
        p.id
      ORDER BY 
        p.created_at DESC
    `;
    // --- END OF CORRECTION ---
    
    const { rows } = await db.query(query);
    res.json(rows);
  } catch (error) {
    console.error('Error fetching patients:', error);
    res.status(500).json({ error: 'Failed to fetch patients.' });
  }
};

/**
 * Fetches all 'active' emergencies for the Emergencies tab.
 */
export const getActiveEmergencies = async (req, res) => {
  try {
    const { rows } = await db.query(
      "SELECT id, patient_name, blood_group, status, city FROM emergency_requests WHERE status = 'active' ORDER BY created_at DESC"
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching active emergencies:', error);
    res.status(500).json({ error: 'Failed to fetch active emergencies.' });
  }
};

/**
 * Fetches all created Blood Bridges for the Blood Bridges tab.
 */
export const getBloodBridges = async (req, res) => {
    try {
        const { rows } = await db.query(
            `SELECT 
                bb.id, 
                bb.name, -- Select the bridge's name
                p.name as patient_name,
                COUNT(bm.id) as member_count -- Count the members in each bridge
             FROM 
                blood_bridges bb
             JOIN 
                patients p ON bb.patient_id = p.id
             LEFT JOIN -- Use LEFT JOIN in case a bridge has 0 members
                bridge_members bm ON bb.id = bm.bridge_id
             WHERE 
                bb.active = true
             GROUP BY -- Required when using an aggregate function like COUNT
                bb.id, p.name
             ORDER BY 
                p.name`
        );
        res.json(rows);
    } catch (error) {
        console.error('Error fetching blood bridges:', error);
        res.status(500).json({ error: 'Failed to fetch blood bridges.' });
    }
};


/**
 * Fetches patients who are due for a transfusion.
 * Logic: Finds patients where today's date is past their last transfusion + frequency.
 */
export const getDuePatients = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT id, name, blood_group, city, last_transfusion_date, frequency_in_days
       FROM patients
       WHERE 
         status = 'bridged' AND 
         last_transfusion_date IS NOT NULL AND 
         frequency_in_days IS NOT NULL AND
         (last_transfusion_date + frequency_in_days * INTERVAL '1 day') <= NOW()`
    );
    res.json(rows);
  } catch (error){
    console.error('Error fetching due patients:', error);
    res.status(500).json({ error: 'Failed to fetch due patients.' });
  }
};

/**
 * Fetches the top 10 donors for the gamification leaderboard.
 */
export const getLeaderboard = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT name, gamification_points, city 
       FROM users 
       WHERE user_type = 'donor' 
       ORDER BY gamification_points DESC 
       LIMIT 10`
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching leaderboard:', error);
    res.status(500).json({ error: 'Failed to fetch leaderboard data.' });
  }
};

// --- Other Endpoints (Placeholders for now) ---
export const getConfig = async (req, res) => { res.json({ message: "Config placeholder" }); };
export const getInboxMessages = async (req, res) => {
  try {
    // This query selects all messages that an admin has not yet marked as 'resolved'.
    const { rows } = await db.query(
      "SELECT id, user_phone, user_message, reason, created_at FROM inbox_messages WHERE status = 'pending' ORDER BY created_at ASC"
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching inbox messages:', error);
    res.status(500).json({ error: 'Failed to fetch inbox messages.' });
  }
};
export const escalateEmergency = async (req, res) => {
  const { requestId } = req.params;
  try {
    const result = await emergencyService.escalateRequest(requestId);
    console.log(`ADMIN ACTION: Escalated emergency request ${requestId}`);
    res.json(result);
  } catch (error) {
    console.error(`Error escalating emergency ${requestId}:`, error);
    res.status(500).json({ error: error.message || 'Failed to escalate emergency.' });
  }
};
export const resolveInboxMessage = async (req, res) => {
  const { messageId } = req.params;
  try {
    const { rowCount } = await db.query(
      "UPDATE inbox_messages SET status = 'resolved', resolved_at = NOW() WHERE id = $1 AND status = 'pending'",
      [messageId]
    );

    if (rowCount === 0) {
      return res.status(404).json({ message: "Pending message not found or it may have been already resolved." });
    }

    console.log(`ADMIN ACTION: Resolved inbox message ${messageId}`);
    res.json({ success: true, message: 'Message marked as resolved.' });
  } catch (error) {
    console.error(`Error resolving inbox message ${messageId}:`, error);
    res.status(500).json({ error: 'Failed to resolve message.' });
  }
};

```

`backend/src/controllers/webhookController.js`

```javascript
// backend/src/controllers/webhookController.js

// Import required dependencies
import config from '../config/config.js';
import db from '../config/db.js';
import emergencyService from '../services/emergencyService.js';
import registrationService from '../services/registrationService.js';
import responseService from '../services/responseService.js';
import patientService from '../services/patientService.js';
import donorPreferenceService from '../services/donorPreferenceService.js';
import aiRouterService from '../services/aiRouterService.js';
import faqService from '../services/faqService.js';
import gamificationService from '../services/gamificationService.js';
import whatsappService from '../services/whatsappService.js';
import bridgeService from '../services/bridgeService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';
import { detectLanguage } from '../utils/languageHelper.js';
import translationService from '../utils/translationService.js';
import { triggerInactiveDonorNudges, triggerAutomaticBridgeRequests } from '../services/schedulerService.js';
import loggingService from '../services/loggingService.js';

/**
 * Handles the GET request from Meta for webhook verification.
 */
const verifyToken = (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode === 'subscribe' && token === config.whatsappVerifyToken) {
    console.log('âœ… Webhook verified successfully!');
    return res.status(200).send(challenge);
  }

  console.warn('Webhook verification failed. Make sure your verify token is correct.');
  res.status(403).send('Verification failed');
};

/**
 * Processes a single, validated incoming WhatsApp message.
 */
const processMessage = async (messageData) => {
  const from = normalizePhoneNumber(messageData.from);

  // --- PRIORITY 0: Handle Non-Text Message Types ---
  if (messageData.type === 'interactive' && messageData.interactive.type === 'button_reply') {
    const buttonId = messageData.interactive.button_reply.id;
    console.log(`--- Interactive Reply --- From: ${from}, Button ID: ${buttonId}`);
    if (buttonId.startsWith('join_bridge_')) {
      await bridgeService.addDonorToBridge(buttonId.replace('join_bridge_', ''));
      await whatsappService.sendTextMessage(from, "Thank you for joining a Blood Bridge! You are now part of a dedicated life-saving team. â¤ï¸");
    } else if (buttonId.startsWith('decline_bridge_')) {
      await whatsappService.sendTextMessage(from, "No problem! We appreciate you being a regular donor and will keep you in mind for general requests.");
    }
    return;
  }
  
  if (messageData.type === 'location') {
    console.log(`--- Location Message --- From: ${from}`);
    await emergencyService.handleLocationReply(from, messageData.location);
    return;
  }

  if (messageData.type !== 'text') {
    console.log(`Ignoring non-text message of type '${messageData.type}' from ${from}.`);
    return;
  }

  // --- Text Message Processing ---
  let userMessage = messageData.text.body.trim();
  
  const detectedLang = await detectLanguage(userMessage);
  if (detectedLang && detectedLang !== 'en') {
      userMessage = await translationService.translateToEnglish(userMessage);
  }
  
  const lowerUserMessage = userMessage.toLowerCase();
  console.log(`--- Processing Message --- From: ${from}, Processed Message: "${userMessage}"`);
  await loggingService.logIncoming(from, userMessage);

  // --- PRIORITY 1: Rigid Commands & State-Based Replies ---
  
  // Smart parser for the multi-line donor registration format
  const registrationDetailsMatch = userMessage.match(/(?:name|full name):\s*(?<name>.+)\s*city:\s*(?<city>.+)\s*blood group:\s*(?<blood_group>.+)/is);
  if (registrationDetailsMatch) {
    console.log(`âœ… Message handled by: Donor Registration Details Parser.`);
    await registrationService.completeDonorRegistration(from, registrationDetailsMatch.groups);
    return;
  }
  
  // Keyword match for DONOR registration
  const isDonorRequest = lowerUserMessage.includes('donor') || lowerUserMessage.includes('donate');
  if (lowerUserMessage.includes('register') && isDonorRequest && !lowerUserMessage.includes('patient')) {
    console.log(`âœ… Message handled by: Donor Registration keyword.`);
    await registrationService.handleNewDonor({}, from);
    return;
  }

  // Keyword match for PATIENT registration
  if ((lowerUserMessage.includes('register') && lowerUserMessage.includes('patient')) || lowerUserMessage.includes('help for a thalassemia patient')) {
    console.log(`âœ… Message handled by: Patient Registration keyword.`);
    await patientService.handleNewPatient({}, from);
    return;
  }

  // Conversational flows and standard replies
  if (await patientService.processOnboardingReply(userMessage, from)) return;
  if (lowerUserMessage === 'apply' && await patientService.startApplication(from)) return;
  if (/^\d{6}$/.test(userMessage)) { await responseService.verifyOTPAndConfirm(from, userMessage); return; }
  if (lowerUserMessage === 'no') { await responseService.handleSimpleDecline(from); return; }
  const responseMatch = userMessage.match(/^(?:YES)\s+(\d{4})$/i);
  if (responseMatch) { await responseService.handleDonorReplyWithShortCode(from, responseMatch[1]); return; }
  if (lowerUserMessage === 'yes') {
    const { rows: [userWithCode] } = await db.query("SELECT last_request_short_code FROM users WHERE phone = $1", [from]);
    if (userWithCode && userWithCode.last_request_short_code) {
        await responseService.handleDonorReplyWithShortCode(from, userWithCode.last_request_short_code);
        return;
    }
  }

  // Demo commands
  if (lowerUserMessage.startsWith('/demo')) {
    console.log('DEMO MODE ACTIVATED');
    if (lowerUserMessage === '/demo nudge') {
        await triggerInactiveDonorNudges();
        await whatsappService.sendTextMessage(from, `ðŸŽ¬ Executed Inactive Donor Nudge.`);
    } else if (lowerUserMessage === '/demo bridge_request') {
        await triggerAutomaticBridgeRequests();
        await whatsappService.sendTextMessage(from, `ðŸŽ¬ Executed Automatic Bridge Requests.`);
    } else {
        await whatsappService.sendTextMessage(from, `Unknown demo command.`);
    }
    return;
  }

  // --- PRIORITY 2: AI-Powered Intent Routing (with context) ---
  console.log(`No direct keyword match found. Routing to AI with conversation context...`);
  const { rows: [user] } = await db.query('SELECT role FROM users WHERE phone = $1', [from]);
  const userRole = user ? user.role : 'Unregistered';
  
  const { rows: historyRows } = await db.query(
    `SELECT message, response FROM conversations WHERE user_phone = $1 ORDER BY created_at DESC LIMIT 3`,
    [from]
  );
  
  const chatHistory = historyRows.reverse().flatMap(row => [
    { role: 'user', parts: [{ text: row.message }] },
    ...(row.response ? [{ role: 'model', parts: [{ text: row.response }] }] : [])
  ]);

  const route = await aiRouterService.routeMessageWithContext(userMessage, userRole, chatHistory);
  
  if (route && route.tool) {
    console.log(`AI routed to tool: ${route.tool}`);
    switch (route.tool) {
      case 'handle_emergency_request':
        await emergencyService.handleEmergencyRequest(userMessage, from);
        break;
      case 'handle_donor_registration':
        await registrationService.handleNewDonor(route.params, from);
        break;
      case 'handle_patient_onboarding':
        await patientService.handleNewPatient(route.params, from);
        break;
      case 'get_my_dashboard': {
        const statusMessage = await gamificationService.getDonorStatus(from);
        await whatsappService.sendTextMessage(from, statusMessage);
        break;
      }
      case 'get_leaderboard': {
        const leaderboardMessage = await gamificationService.getLeaderboardMessage(from);
        await whatsappService.sendTextMessage(from, leaderboardMessage);
        break;
      }
      case 'handle_join_bridge_request': {
        const msg = await bridgeService.addDonorToBridgeByPhone(from);
        await whatsappService.sendTextMessage(from, msg);
        break;
      }
      case 'handle_snooze_request':
        await donorPreferenceService.handleSnooze(from, route.params);
        break;
      default:
        await faqService.handleFaq(userMessage, from);
        break;
    }
    return;
  }

  // --- PRIORITY 3: Final Fallback ---
  console.log(`AI did not select a tool. Handling as a general FAQ.`);
  await faqService.handleFaq(userMessage, from);
};

/**
 * The main entry point for the /webhook POST request.
 */
const handleMessage = async (req, res) => {
  res.sendStatus(200);

  try {
    const messageData = req.body.entry?.[0]?.changes?.[0]?.value?.messages?.[0];
    if (!messageData) {
      return;
    }

    const messageId = messageData.id;
    const { rows } = await db.query('SELECT 1 FROM processed_messages WHERE message_id = $1', [messageId]);
    if (rows.length > 0) {
      console.warn(`Duplicate message ignored: ${messageId}`);
      return;
    }
    
    await db.query('INSERT INTO processed_messages(message_id) VALUES($1)', [messageId]);
    await processMessage(messageData);

  } catch (error) {
    console.error('CRITICAL ERROR in handleMessage:', {
      message: error.message,
      stack: error.stack,
    });
  }
};

export default {
  verifyToken,
  handleMessage,
};

```

`backend/src/middleware/authMiddleware.js`

```javascript
// backend/src/middleware/authMiddleware.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';

// âœ… The function must be declared as a constant named 'authMiddleware'
const authMiddleware = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authorization token is missing or malformed' });
  }

  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, config.jwtSecret);
    req.user = decoded;
    next();
  } catch (error) {
    console.error("JWT Verification Error:", error.message);
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
};

// âœ… This line then exports that constant
export default authMiddleware;

```

`backend/src/middleware/checkRole.js`

```javascript
// backend/src/middleware/checkRole.js

const checkRole = (roles) => {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: 'Forbidden: No role assigned' });
    }
    const userRole = req.user.role;
    if (roles.includes(userRole)) {
      return next();
    }
    return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
  };
};

export default checkRole; // <-- CORRECTED LINE

```

`backend/src/middleware/verifyWebhook.js`

```javascript
// backend/src/middleware/verifyWebhook.js
import crypto from 'crypto';
import config from '../config/config.js';

/**
 * Middleware to verify WhatsApp webhook POST requests.
 * - Skips signature verification for GET (used by Meta for challenge verification).
 * - Validates signature for POST requests to ensure authenticity.
 */
export const verifyWebhook = (req, res, next) => {
  // Allow GET requests (Meta verification step) to pass through.
  if (req.method === 'GET') {
    return next();
  }

  // Get the signature from the request header.
  const signature = req.headers['x-hub-signature-256'];
  if (!signature) {
    console.warn('Signature missing for POST webhook');
    return res.status(401).json({ message: 'Signature missing' });
  }

  // --- THIS IS THE CORRECTED SECTION ---
  // Create an HMAC (Hash-based Message Authentication Code) using sha256.
  // We use the `whatsappAppSecret` as the key.
  const hmac = crypto.createHmac('sha256', config.whatsappAppSecret);

  // We MUST use the raw request body string that we saved earlier in server.js.
  // Using `req.body` here will fail because it's already parsed JSON.
  hmac.update(req.rawBody);
  const expectedSignature = `sha256=${hmac.digest('hex')}`;
  // --- END OF CORRECTION ---

  // Compare the signature from Meta with the one we calculated.
  // We use a timing-safe comparison to enhance security.
  // An invalid signature means the request might be forged.
  if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))) {
    console.warn('Signature mismatch for POST webhook. Check your WHATSAPP_APP_SECRET.');
    return res.status(401).json({ message: 'Invalid signature' });
  }

  // If the signatures match, the request is authentic. Proceed to the next middleware.
  next();
};

```

`backend/src/routes/adminRoutes.js`

```javascript
// backend/src/routes/adminRoutes.js
import express from 'express';
import {
  login,
  createBridgeForPatient,
  closeEmergency,
  requestBridgeTransfusion,
  getDashboardStats,
  getBloodGroupStats,
  getPatients,
  getActiveEmergencies,
  getBloodBridges,
  getDuePatients,
  getLeaderboard,
  getInboxMessages,
  escalateEmergency,
  resolveInboxMessage,
  getConfig
} from '../controllers/adminController.js';
import authMiddleware from '../middleware/authMiddleware.js';
import checkRole from '../middleware/checkRole.js';

const router = express.Router();

// Public (no auth needed)
router.post('/login', login);

// All routes below this require auth
router.use(authMiddleware);

// --- DASHBOARD GET ROUTES ---
router.get('/config', checkRole(['Admin']), getConfig);
router.get('/stats', checkRole(['Admin']), getDashboardStats);
router.get('/stats/blood-groups', checkRole(['Admin']), getBloodGroupStats);
router.get('/patients', checkRole(['Admin']), getPatients);
router.get('/patients/due', checkRole(['Admin']), getDuePatients);
router.get('/emergencies', checkRole(['Admin']), getActiveEmergencies);
router.get('/bridges', checkRole(['Admin']), getBloodBridges);
router.get('/leaderboard', checkRole(['Admin']), getLeaderboard);
router.get('/inbox', checkRole(['Admin']), getInboxMessages);

// --- ACTION ROUTES ---
router.post('/patients/:patientId/create-bridge', checkRole(['Admin']), createBridgeForPatient);
router.post('/emergencies/:requestId/close', checkRole(['Admin']), closeEmergency);
router.post('/emergencies/:requestId/escalate', checkRole(['Admin']), escalateEmergency);
router.post('/bridges/:bridgeId/request', checkRole(['Admin']), requestBridgeTransfusion);
router.post('/inbox/:messageId/resolve', checkRole(['Admin']), resolveInboxMessage);

export default router;

```

`backend/src/services/aiRouterService.js`

```javascript
// backend/src/services/aiRouterService.js
import { GoogleGenerativeAI } from '@google/generative-ai';
import { TOOL_DEFINITIONS } from './aiTools.js'; // âœ… This import MUST be in this file.
import config from '../config/config.js';

class AIRouterService {
  constructor() {
    if (!config.geminiApiKey) {
      throw new Error("GEMINI_API_KEY is not set.");
    }
    this.genAI = new GoogleGenerativeAI(config.geminiApiKey);
    this.model = this.genAI.getGenerativeModel({
      model: 'gemini-1.5-flash-latest',
      // This line now works because TOOL_DEFINITIONS is correctly imported above.
      tools: { functionDeclarations: TOOL_DEFINITIONS }
    });
  }

  // âœ… This is the complete, context-aware version of this function.
  async routeMessageWithContext(userMessage, userRole, chatHistory = []) {
    const systemPrompt = `You are "Bridge AI", an AI assistant. Your goal is to understand the user's message in the context of the conversation and call the appropriate function. The user's role is "${userRole}".`;
    
    const fullHistory = [
      { role: "user", parts: [{ text: systemPrompt }] },
      { role: "model", parts: [{ text: "Understood." }] },
      ...chatHistory
    ];
    
    try {
      const chat = this.model.startChat({ history: fullHistory });
      const result = await chat.sendMessage(userMessage);
      const call = result.response.functionCalls()?.[0];
      
      if (call) {
        console.log(`AI decided to call tool: ${call.name} with params:`, call.args);
        return { tool: call.name, params: call.args };
      }
      console.log("AI did not call a specific tool for this message.");
      return null;
    } catch (error) {
      console.error('Error routing message with Gemini:', error.message);
      return null;
    }
  }
}

export default new AIRouterService();

```

`backend/src/services/aiTools.js`

```javascript
// backend/src/services/aiTools.js

/**
Â * TOOL_DEFINITIONS is a manifest of functions the Gemini AI can call.
Â * The descriptions are critical, as they tell the AI *when* to use each tool.
Â */
export const TOOL_DEFINITIONS = [
Â  {
Â  Â  name: 'handle_emergency_request',
Â  Â  description: `Use for any urgent, one-time blood request. The message may contain details like blood group, city, or hospital.`,
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {
Â  Â  Â  Â  patient_name: { type: 'string', description: 'Name of the patient needing blood. If not mentioned, use "Unknown".' },
Â  Â  Â  Â  blood_group: { type: 'string', description: 'The blood group needed, like A+, O-, AB+.' },
Â  Â  Â  Â  city: { type: 'string', description: 'The city where the hospital is located.' }
Â  Â  Â  },
Â  Â  Â  required: ['blood_group', 'city']
Â  Â  }
Â  },
  {
    // âœ… UPDATED: This tool can now extract parameters from a detailed message.
    name: 'handle_patient_onboarding',
    description: `Use when a user wants to register a PATIENT for long-term support. This is for long-term care, not one-time emergencies. Extract the patient's name, city, and blood group if provided.`,
    parameters: {
      type: 'object',
      properties: {
        patient_name: { type: 'string', description: 'The name of the patient. Default to "the patient" if not specified.' },
        city: { type: 'string', description: 'The city where the patient needs support.' },
        blood_group: { type: 'string', description: "The patient's blood group." }
      },
      required: [] // Parameters are optional, the bot can ask for them if missing.
    }
  },
Â  {
    // âœ… This description is now more specific to donors.
Â  Â  name: 'handle_donor_registration',
Â  Â  description: `Use when a user wants to register as a DONOR or makes a generic registration request like "register me" or "create an account". Key phrases are "I want to donate", "register me as a donor", or "sign me up". Do NOT use this tool if the user mentions "patient".`,
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {
Â  Â  Â  Â  name: { type: 'string', description: 'Full name of the new donor. Default to "Unknown".' },
Â  Â  Â  Â  blood_group: { type: 'string', description: 'The blood group of the person. Default to "Unknown".' },
Â  Â  Â  Â  city: { type: 'string', description: 'The city where the donor lives. Default to "Unknown".' }
Â  Â  Â  },
Â  Â  Â  required: []
Â  Â  }
Â  },
  {
    name: 'handle_join_bridge_request',
    description: `Use when an EXISTING registered donor specifically asks to join a "Blood Bridge". This is a rotational system for supporting a specific patient.`,
    parameters: { 
      type: 'object', 
      properties: {}
    }
  },

Â  {
Â  Â  name: 'handle_snooze_request',
Â  Â  description: 'Use when a donor wants to temporarily pause notifications. It can understand durations like "a month", "10 days", "2 weeks".',
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {
Â  Â  Â  Â  duration: { type: 'integer', description: 'The number value for the duration (e.g., 10 for "10 days").' },
Â  Â  Â  Â  unit: { type: 'string', enum: ['day', 'week', 'month'], description: 'The unit of time for the snooze.' }
Â  Â  Â  },
Â  Â  Â  required: ['duration', 'unit']
Â  Â  }
Â  },
Â  {
Â  Â  name: 'get_my_dashboard',
Â  Â  description: 'Use this when a registered donor asks for their personal status, points, badges, or "mydashboard".',
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {},
Â  Â  Â  required: []
Â  Â  }
Â  },
Â  {
Â  Â  name: 'get_leaderboard',
Â  Â  description: 'Use this when a user asks to see the "leaderboard", "top donors", or "rankings".',
Â  Â  parameters: {
Â  Â  Â  type: 'object',
Â  Â  Â  properties: {},
Â  Â  Â  required: []
Â  Â  }
Â  },
];

```

`backend/src/services/bridgeCoordinationService.js`

```javascript
// backend/src/services/bridgeCoordinationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateShortCode } from '../utils/otpHelper.js';

class BridgeCoordinationService {
  async requestTransfusion(bridgeId) {
    const { rows: [bridge] } = await db.query(
      `SELECT bb.*, p.name as patient_name
       FROM blood_bridges bb
       JOIN patients p ON bb.patient_id = p.id
       WHERE bb.id = $1`,
      [bridgeId]
    );
    if (!bridge) throw new Error(`Blood Bridge with ID ${bridgeId} not found.`);

    // --- NEW LOGIC: PREVENT DUPLICATE REQUESTS ---
    if (bridge.active_request_id) {
      throw new Error(`Request failed: Patient ${bridge.patient_name} already has an active bridge request.`);
    }
    // --- END NEW LOGIC ---

    const { rows: members } = await db.query(
      // Find the next donor who is currently 'available'
      `SELECT u.id, u.name, u.phone
       FROM bridge_members bm
       JOIN users u ON bm.donor_id = u.id
       WHERE bm.bridge_id = $1 AND bm.status = 'active' AND u.availability_status = 'available'
       ORDER BY bm.position ASC`,
      [bridgeId]
    );

    if (members.length === 0) {
      // This is a "Bridge Failure" scenario. We need to escalate.
      // For now, we'll throw an error that the admin will see.
      // In Task 4 (Escalation), we will automate this.
      throw new Error(`No available donors found in the bridge for ${bridge.patient_name}. Please escalate to a general emergency.`);
    }

    const donorToNotify = members[0]; // The SQL query now only returns available donors in order

    const shortCode = generateShortCode();
    // Create the request and get its ID back
    const { rows: [newRequest] } = await db.query(
      `INSERT INTO emergency_requests (patient_name, blood_group, city, requested_by_phone, short_code, request_type, bridge_id, units_needed)
       VALUES ($1, $2, $3, 'system', $4, 'bridge', $5, 1) RETURNING id;`,
      [bridge.patient_name, bridge.blood_group, bridge.city, shortCode, bridge.id]
    );

    // --- NEW LOGIC: LINK THE ACTIVE REQUEST TO THE BRIDGE ---
    await db.query(
        'UPDATE public.blood_bridges SET active_request_id = $1 WHERE id = $2',
        [newRequest.id, bridgeId]
    );
    // --- END NEW LOGIC ---

    const message = `Hi ${donorToNotify.name}, it's your turn in the Blood Bridge for patient *${bridge.patient_name}*.\n\nYour help is needed for their scheduled transfusion. Please reply with *YES ${shortCode}* to confirm your availability.`;
    await whatsappService.sendTextMessage(donorToNotify.phone, message);

    return { success: true, message: `Successfully notified ${donorToNotify.name} for patient ${bridge.patient_name}.` };
  }
  
  async rotateBridge(bridgeId, client = db) {
    // This function now does two things: rotates the position AND clears the active request ID.
    const { rows: [bridge] } = await client.query('SELECT rotation_position FROM blood_bridges WHERE id = $1', [bridgeId]);
    const { rows: [{ count }] } = await client.query('SELECT COUNT(*) FROM bridge_members WHERE bridge_id = $1 AND status = \'active\'', [bridgeId]);

    if (!bridge || count === '0') {
      console.error(`Cannot rotate bridge ${bridgeId}: Bridge or members not found.`);
      return;
    }

    const totalMembers = parseInt(count, 10);
    // We use the current position to find the next one, ensuring rotation
    const currentPositionInList = (bridge.rotation_position - 1);
    const nextPosition = (currentPositionInList % totalMembers) + 1;

    // Update bridge: clear active request and set new rotation position
    await client.query(
      'UPDATE blood_bridges SET rotation_position = $1, active_request_id = NULL WHERE id = $2',
      [nextPosition, bridgeId]
    );
    console.log(`Blood Bridge ${bridgeId} rotated successfully to position ${nextPosition} and cleared active request.`);
  }  // In backend/src/services/bridgeCoordinationService.js, inside the class

  /**
   * Finds all bridged patients who are due for a transfusion and initiates the request.
   * This is designed to be run automatically by a scheduler.
   */
  async triggerAutomaticBridgeRequests() {
    console.log('CRON JOB: Checking for due bridge patients...');
    try {
      // 1. Find all patients who are bridged and due for a transfusion today or in the past.
      const { rows: duePatients } = await db.query(
        `SELECT p.id, p.name, bb.id as bridge_id
         FROM patients p
         JOIN blood_bridges bb ON p.id = bb.patient_id
         WHERE 
           p.status = 'bridged' AND 
           p.last_transfusion_date IS NOT NULL AND 
           p.frequency_in_days IS NOT NULL AND
           (p.last_transfusion_date + p.frequency_in_days * INTERVAL '1 day') <= NOW() AND
           bb.active_request_id IS NULL -- IMPORTANT: Only trigger if there isn't one already active
        `
      );

      if (duePatients.length === 0) {
        console.log('CRON JOB: No patients are due for an automatic bridge request today.');
        return;
      }

      console.log(`CRON JOB: Found ${duePatients.length} patient(s) due for transfusion. Initiating requests...`);

      // 2. Loop through each due patient and call the existing requestTransfusion function.
      for (const patient of duePatients) {
        console.log(`CRON JOB: Initiating request for patient ${patient.name} (Bridge ID: ${patient.bridge_id})`);
        try {
          // We reuse the same logic that the admin dashboard button uses.
          await this.requestTransfusion(patient.bridge_id);
        } catch (error) {
          console.error(`CRON JOB: Failed to initiate request for bridge ${patient.bridge_id}. Reason: ${error.message}`);
          // In a production system, you might send an alert to an admin here.
        }
      }
    } catch (error) {
      console.error("CRITICAL ERROR in cron job triggerAutomaticBridgeRequests:", error);
    }
  }

/**
 * Finds all bridged patients who are due for a transfusion and initiates the request.
 * This is designed to be run automatically by a scheduler.
 */
async triggerAutomaticBridgeRequests() {
  console.log('CRON JOB: Checking for due bridge patients...');
  try {
    // 1. Find all patients who are bridged and due for a transfusion today or in the past.
    const { rows: duePatients } = await db.query(
      `SELECT p.id, p.name, bb.id as bridge_id
       FROM patients p
       JOIN blood_bridges bb ON p.id = bb.patient_id
       WHERE 
         p.status = 'bridged' AND 
         p.last_transfusion_date IS NOT NULL AND 
         p.frequency_in_days IS NOT NULL AND
         (p.last_transfusion_date + p.frequency_in_days * INTERVAL '1 day') <= NOW() AND
         bb.active_request_id IS NULL -- IMPORTANT: Only trigger if there isn't one already active
      `
    );

    if (duePatients.length === 0) {
      console.log('CRON JOB: No patients are due for an automatic bridge request today.');
      return;
    }

    console.log(`CRON JOB: Found ${duePatients.length} patient(s) due for transfusion. Initiating requests...`);

    // 2. Loop through each due patient and call the existing requestTransfusion function.
    for (const patient of duePatients) {
      console.log(`CRON JOB: Initiating request for patient ${patient.name} (Bridge ID: ${patient.bridge_id})`);
      try {
        // We reuse the same logic that the admin dashboard button uses.
        await this.requestTransfusion(patient.bridge_id);
      } catch (error) {
        console.error(`CRON JOB: Failed to initiate request for bridge ${patient.bridge_id}. Reason: ${error.message}`);
        // In a production system, you might send an alert to an admin here.
      }
    }
  } catch (error) {
    console.error("CRITICAL ERROR in cron job triggerAutomaticBridgeRequests:", error);
  }
}
}

export default new BridgeCoordinationService();

```

`backend/src/services/bridgeService.js`

```javascript
// backend/src/services/bridgeService.js
import db from '../config/db.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class BridgeService {
  /**
   * Finds the best active bridge for a new donor to join based on city and blood group.
   * "Best" is defined as the bridge with the fewest members, to ensure balance.
   */
  async findBestBridgeForDonor(city, bloodGroup) {
    const query = `
      SELECT bb.id, bb.name FROM blood_bridges bb
      LEFT JOIN bridge_members bm ON bb.id = bm.bridge_id
      WHERE bb.city ILIKE $1 AND bb.blood_group = $2 AND bb.active = true
      GROUP BY bb.id, bb.name
      HAVING COUNT(bm.id) < 10 -- Only consider bridges that are not full
      ORDER BY COUNT(bm.id) ASC, bb.created_at ASC -- Prioritize the least full, oldest bridge
      LIMIT 1;
    `;
    const { rows: [bestBridge] } = await db.query(query, [`%${city}%`, bloodGroup]);
    return bestBridge;
  }

  /**
   * Adds a donor to the best available bridge.
   * @param {string} donorId - The UUID of the donor to add.
   */
  async addDonorToBridge(donorId) {
    try {
      const { rows: [donor] } = await db.query('SELECT city, blood_group FROM users WHERE id = $1', [donorId]);
      if (!donor) throw new Error('Donor not found.');
      
      const bridge = await this.findBestBridgeForDonor(donor.city, donor.blood_group);
      if (!bridge) {
        console.log(`No active bridge with available space found for ${donor.city}/${donor.blood_group}.`);
        return { success: true, status: 'no_bridge_found' };
      }

      await db.query(
        "INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, (SELECT COALESCE(MAX(position), 0) + 1 FROM bridge_members WHERE bridge_id = $1)) ON CONFLICT DO NOTHING",
        [bridge.id, donorId]
      );

      console.log(`Successfully added donor ${donorId} to bridge: ${bridge.name} (${bridge.id}).`);
      return { success: true, status: 'added_to_bridge' };
    } catch (error) {
      console.error('Error adding donor to bridge:', error);
      return { success: false, error };
    }
  }

  /**
   * Handles a request from a donor to join a bridge via their phone number.
   */
  async addDonorToBridgeByPhone(donorPhone) {
    const sanitizedPhone = normalizePhoneNumber(donorPhone);
    try {
      const { rows: [donor] } = await db.query('SELECT id, name, city, blood_group FROM users WHERE phone = $1', [sanitizedPhone]);
      if (!donor) {
        return "It looks like you're not registered yet. Please register first!";
      }
     
      const { rows: [existingMember] } = await db.query('SELECT id FROM bridge_members WHERE donor_id = $1', [donor.id]);
      if (existingMember) {
        return `Thank you, ${donor.name}! You are already a valued member of a Blood Bridge.`;
      }
      const bridge = await this.findBestBridgeForDonor(donor.city, donor.blood_group);
      if (!bridge) {
        return `Thank you for your interest, ${donor.name}! We don't have a Blood Bridge matching your profile right now, but we'll notify you when one becomes available.`;
      }
      await db.query(
        "INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, (SELECT COALESCE(MAX(position), 0) + 1 FROM bridge_members WHERE bridge_id = $1)) ON CONFLICT DO NOTHING",
        [bridge.id, donor.id]
      );
     
      return `Welcome to ${bridge.name}! You are now part of a dedicated life-saving team. â¤ï¸`;
    } catch (error) {
      console.error('Error adding donor to bridge by phone:', error);
      return 'Sorry, we encountered an error. Please try again later.';
    }
  }

  /**
   * Populates a newly created bridge with the best-matched donors from the general pool.
   */
  async populateNewBridge(bridgeId, city, bloodGroup, pincode) {
    try {
      console.log(`Populating bridge ${bridgeId} for city: ${city}, blood group: ${bloodGroup}, pincode: ${pincode}`);
      const { rows: bestDonors } = await db.query(
        'SELECT donor_id, final_score FROM find_donors_for_bridge($1, $2, $3, $4)',
        [city, bloodGroup, pincode, 8]
      );
      
      if (!bestDonors || bestDonors.length === 0) {
        console.warn(`No donors found for bridge ${bridgeId}`);
        return { success: true, count: 0 };
      }

      const insertQueries = bestDonors.map((donor, index) =>
        db.query(
          'INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, $3)',
          [bridgeId, donor.donor_id, index + 1]
        )
      );

      await Promise.all(insertQueries);
      console.log(`Successfully populated bridge ${bridgeId} with ${bestDonors.length} donors`);
      return { success: true, count: bestDonors.length };
    } catch (error) {
      console.error(`Error populating bridge ${bridgeId}:`, {
        error: error.message, city, bloodGroup, pincode,
      });
      throw new Error(`Failed to populate bridge: ${error.message}`);
    }
  }
}

export default new BridgeService(); 

```

`backend/src/services/donorPreferenceService.js`

```javascript
// backend/src/services/donorPreferenceService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class DonorPreferenceService {
  /**
   * Sets a snooze period for a donor, pausing notifications.
   * @param {string} phone - The donor's phone number.
   * @param {object} params - Parameters from the AI, e.g., { duration: 1, unit: 'week' }.
   */
  async handleSnooze(phone, params) {
    const { duration = 15, unit = 'day' } = params; // Default to 15 days if AI provides no params
    
    try {
      const interval = `${duration} ${unit}`;
      const { rows: [user] } = await db.query(
        "UPDATE users SET snooze_until = NOW() + $1::interval WHERE phone = $2 RETURNING snooze_until",
        [interval, phone]
      );

      if (user && user.snooze_until) {
        const snoozeDate = new Date(user.snooze_until).toLocaleDateString('en-IN');
        const message = `Got it. I've paused all non-critical notifications for you until ${snoozeDate}. We'll reach out again after that. Thank you for being a donor!`;
        await whatsappService.sendTextMessage(phone, message);
      }
    } catch (error) {
      console.error(`Error setting snooze for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while setting your preferences.");
    }
  }

  /**
   * Sets the Do Not Disturb (DND) status for a donor, permanently stopping notifications.
   * @param {string} phone - The donor's phone number.
   */
  async handleDnd(phone) {
    try {
      await db.query(
        "UPDATE users SET dnd_status = true, availability_status = 'unavailable' WHERE phone = $1",
        [phone]
      );
      const message = "You have been unsubscribed from all future notifications. We're sad to see you go, but we respect your decision. If you ever change your mind, just send 'Register' to sign up again.";
      await whatsappService.sendTextMessage(phone, message);
    } catch (error) {
      console.error(`Error setting DND for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while updating your DND status.");
    }
  }
}

export default new DonorPreferenceService();

```

`backend/src/services/emergencyService.js`

```javascript
// backend/src/services/emergencyService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import aiRouterService from './aiRouterService.js';
import mlService from './mlService.js';
import geocodingService from './geocodingService.js';
import { getDistanceInKm } from '../utils/distanceHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

const VALID_BLOOD_GROUPS = ['A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'];
const activeTimeouts = new Map();

class EmergencyService {
  async handleEmergencyRequest(userMessage, requesterPhone) {
    const sanitizedPhone = normalizePhoneNumber(requesterPhone);
    try {
      const route = await aiRouterService.routeMessageWithContext(userMessage, 'Unregistered');
      if (route && route.tool === 'handle_emergency_request' && route.params.blood_group && route.params.city) {
        console.log("AI successfully extracted details:", route.params);
        await this.createEmergencyRequest(route.params, sanitizedPhone);
      } else {
        console.log('AI could not extract necessary details. Prompting user.');
        const followupMessage = "I understand this is an emergency. To find a donor, please provide the patient's blood group (e.g., A+, O-) and the city where the hospital is located.";
        await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);
      }
    } catch (error) {
      console.error('CRITICAL ERROR in handleEmergencyRequest:', error);
      await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }  

  async createEmergencyRequest(params, requesterPhone) {
    const { 
      patient_name = 'Unknown', 
      blood_group, 
      city, 
      hospital_name = 'Unknown', 
      units_needed = 1
    } = params;
    try {
      const normalizedBG = normalizeBloodGroup(blood_group);
      if (!VALID_BLOOD_GROUPS.includes(normalizedBG)) {
        const validationErrorMessage = `Sorry, "${blood_group}" is not a recognized blood group. Please use a valid one (e.g., O+, AB-).`;
        await whatsappService.sendTextMessage(requesterPhone, validationErrorMessage);
        return;
      }
      
      const coords = await geocodingService.getCoords(hospital_name, city, null).catch(err => {
        console.error("Geocoding service failed, but continuing without coordinates.", err);
        return null;
      });

      const shortCode = Math.floor(1000 + Math.random() * 9000).toString();

      const { rows: [request] } = await db.query(
        `INSERT INTO emergency_requests (patient_name, blood_group, city, hospital_name, requested_by_phone, short_code, latitude, longitude, units_needed)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *;`,
        [patient_name, normalizedBG, city, hospital_name, requesterPhone, shortCode, coords?.latitude, coords?.longitude, units_needed]
      );
      
      console.log(`Successfully created emergency request ID: ${request.id}`);
      await whatsappService.sendTextMessage(requesterPhone, `âœ… Emergency request active! We are now running a hyperlocal search for *${patient_name}*.`);
      
      await this.findAndNotifyDonors(request);
    } catch (error) {
      console.error('CRITICAL ERROR creating emergency request in database:', error);
      await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }
  
  async findAndNotifyDonors(request) {
    const TIMEOUT_IN_MINUTES = 2;
    const { id: requestId, requested_by_phone } = request;
    
    try {
      // 1. Find all donors who have already been contacted for this request.
      const { rows: notifiedDonors } = await db.query(
        'SELECT donor_id FROM donor_responses WHERE request_id = $1',
        [requestId]
      );
      const excludedDonorIds = notifiedDonors.map(d => d.donor_id);

      // 2. Find the next best available donors.
      let topScoredDonors = await this.findAndRankGeneralDonors(request.blood_group, request.city, excludedDonorIds);

      // 3. Handle the case where no donors are left.
      if (topScoredDonors.length === 0) {
        console.warn(`Search complete for request ${requestId}: No new donors found.`);
        const alertMessage = `âš ï¸ We have contacted all available donors in our network for *${request.patient_name}*. This request has been flagged for admin review.`;
        await whatsappService.sendTextMessage(requested_by_phone, alertMessage);
        await db.query("INSERT INTO inbox_messages (user_phone, user_message, reason) VALUES ($1, $2, $3)", [requested_by_phone, `Donor search exhausted for patient ${request.patient_name}`, 'Donor Search Exhausted']);
        return;
      }

      // 4. Select only the single best donor from the list.
      const bestDonor = topScoredDonors[0];
      
      const notificationMessage = 
          `ðŸš¨ URGENT: A patient needs your help!\n\n` +
          `Patient: *${request.patient_name}*\n` +
          `Blood Group: *${request.blood_group}*\n` +
          `Location: ${request.hospital_name}, ${request.city}\n\n` +
          `To confirm you can donate, please reply with: *YES ${request.short_code}*\n\n` +
          `If you are unable to help, please reply "NO" so we can find another hero quickly.`;
        
      // 5. Log the attempt and send the message to the single best donor.
      await db.query(`INSERT INTO donor_responses (donor_id, request_id, response) VALUES ($1, $2, 'pending') ON CONFLICT (donor_id, request_id) DO UPDATE SET response = 'pending'`, [bestDonor.id, requestId]);
      await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [bestDonor.id]);
      await whatsappService.sendTextMessage(bestDonor.phone, notificationMessage);
      
      // 6. Inform the requester and set the automatic escalation timeout.
      const adminMessage = `âœ… Search ongoing... Notifying the best match: *${bestDonor.name}*. If they don't respond in ${TIMEOUT_IN_MINUTES} minutes, we will contact the next donor.`;
      await whatsappService.sendTextMessage(requested_by_phone, adminMessage);

      const timeoutId = setTimeout(() => {
        console.log(`[TIMEOUT] Donor ${bestDonor.name} did not respond for request ${requestId}. Escalating...`);
        this.findNextDonorForRequest(requestId);
      }, TIMEOUT_IN_MINUTES * 60 * 1000);

      activeTimeouts.set(requestId.toString(), timeoutId);

    } catch (error) {
      console.error(`CRITICAL ERROR in findAndNotifyDonors for request ${requestId}:`, error);
      await whatsappService.sendTextMessage(requested_by_phone, 'We encountered a system error while searching for donors. Our team has been notified.');
    }
  }

  async findNextDonorForRequest(requestId) {
    console.log(`[ESCALATION] Finding next donor batch for request ${requestId}`);
    this.clearEmergencyTimeout(requestId);
    const { rows: [requestInfo] } = await db.query(`SELECT * FROM emergency_requests WHERE id = $1`, [requestId]);
    
    if (requestInfo && requestInfo.status === 'active') {
      await this.findAndNotifyDonors(requestInfo);
    } else {
      console.warn(`[ESCALATION] Not proceeding for request ${requestId}, status is '${requestInfo ? requestInfo.status : 'NOT FOUND'}'`);
    }
  }

  async escalateRequest(requestId) {
    const BATCH_SIZE = 10;
    try {
      const { rows: [request] } = await db.query(
          'SELECT * FROM emergency_requests WHERE id = $1 AND status = \'active\'',
          [requestId]
      );
      if (!request) {
          throw new Error('Active emergency request not found.');
      }

      const { rows: notifiedDonors } = await db.query(
          'SELECT donor_id FROM donor_responses WHERE request_id = $1',
          [requestId]
      );
      const excludedDonorIds = notifiedDonors.map(d => d.donor_id);
      console.log(`Escalating request ${requestId}. Excluding ${excludedDonorIds.length} already-notified donor(s).`);
      
      const nextDonors = await this.findAndRankGeneralDonors(
          request.blood_group,
          request.city,
          excludedDonorIds
      );
      if (nextDonors.length === 0) {
          throw new Error('No additional available donors found in the network for this request.');
      }

      const batchToNotify = nextDonors.slice(0, BATCH_SIZE);
      const notificationPromises = batchToNotify.map(async (donor) => {
          try {
              const notificationMessage = `ðŸš¨ URGENT (Escalated): You are a top match for an emergency!\n\nPatient *${request.patient_name}* needs your help (${request.blood_group}).\n\nReply *YES ${request.short_code}* to help.`;
              
              await db.query(`INSERT INTO donor_responses (donor_id, request_id, response) VALUES ($1, $2, 'pending') ON CONFLICT (donor_id, request_id) DO NOTHING;`, [donor.id, requestId]);
              const result = await whatsappService.sendTextMessage(donor.phone, notificationMessage);
              
              if(result.success) {
                  await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [donor.id]);
              }
          } catch (err) {
              console.error(`Failed to notify donor ${donor.id} for request ${requestId}:`, err.message);
          }
      });

      await Promise.all(notificationPromises);
      const adminMessage = `âœ… Escalation successful. Notified a batch of ${batchToNotify.length} new top-ranked donors.`;
      await whatsappService.sendTextMessage(request.requested_by_phone, adminMessage);
      
      return { success: true, message: `Successfully escalated request and notified ${batchToNotify.length} new donors.` };
    } catch (error) {
      console.error(`CRITICAL ERROR during escalation for request ${requestId}:`, error);
      throw error;
    }
  }
  
  clearEmergencyTimeout(requestId) {
    if (activeTimeouts.has(requestId.toString())) {
      clearTimeout(activeTimeouts.get(requestId.toString()));
      activeTimeouts.delete(requestId.toString());
      console.log(`[TIMEOUT CLEARED] Timeout for request ${requestId} has been stopped.`);
    }
  }

  async findAndRankGeneralDonors(bloodGroup, city, excludedDonorIds = []) {
    const { rows: availableDonors } = await db.query(
      `SELECT id, name, phone, last_donation, notifications_received, donations_confirmed, streak_count, latitude, longitude
       FROM users
       WHERE user_type = 'donor' AND blood_group = $1 AND city ILIKE $2
         AND availability_status = 'available' AND dnd_status = false
         AND (snooze_until IS NULL OR snooze_until < NOW())
         AND id NOT IN (SELECT unnest($3::uuid[]))
       LIMIT 50;`,
      [normalizeBloodGroup(bloodGroup), city, excludedDonorIds]
    );
    if (!availableDonors || availableDonors.length === 0) return [];
    
    const scoringPromises = availableDonors.map(donor => mlService.scoreSingleDonor(donor));
    const results = await Promise.allSettled(scoringPromises);
    
    const scoredDonors = availableDonors.map((donor, index) => {
        const score = results[index].status === 'fulfilled' ? results[index].value.final_score : 0;
        return { ...donor, final_score: score };
    });
    
    scoredDonors.sort((a, b) => b.final_score - a.final_score);
    return scoredDonors;
  }
}

export default new EmergencyService();

```

`backend/src/services/engagementService.js`

```javascript
// backend/src/services/engagementService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class EngagementService {
  /**
   * Finds donors whose 90-day cooldown period has ended and reminds them
   * that they are now eligible to donate again.
   */
  async sendEligibilityReminders() {
    console.log('CRON JOB: Running sendEligibilityReminders...');
    try {
      // 1. Find all donors who are ready to be re-activated.
      // - Their cooldown must have expired (cooldown_until <= NOW()).
      // - Their status must currently be 'unavailable' (from their last donation).
      // - They must not have opted out of all notifications (dnd_status = false).
      const { rows: eligibleDonors } = await db.query(
        `SELECT id, name, phone
         FROM users
         WHERE user_type = 'donor'
           AND availability_status = 'unavailable'
           AND dnd_status = false
           AND cooldown_until <= NOW()`
      );

      if (eligibleDonors.length === 0) {
        console.log('CRON JOB: No donors are newly eligible today.');
        return;
      }

      console.log(`CRON JOB: Found ${eligibleDonors.length} newly eligible donors. Preparing to send reminders.`);

      // 2. Prepare all the database updates.
      // We will collect all the user IDs to update their status in a single efficient query.
      const donorIdsToUpdate = eligibleDonors.map(donor => donor.id);
      const updatePromise = db.query(
        "UPDATE users SET availability_status = 'available' WHERE id = ANY($1::uuid[])",
        [donorIdsToUpdate]
      );

      // 3. Prepare all the WhatsApp messages.
      // We will send messages concurrently for maximum speed.
      const messagePromises = eligibleDonors.map(donor => {
        const message = `Hi ${donor.name}! ðŸ‘‹\n\nGreat news! Your 90-day waiting period is over, and you are now eligible to save a life again.\n\nYour status has been updated to "Available". Thank you for being a vital part of the BloodBridge community! â¤ï¸`;
        return whatsappService.sendTextMessage(donor.phone, message);
      });

      // 4. Execute all promises (database updates and messages).
      // Promise.allSettled is used so that if one message fails, it doesn't stop the others.
      const results = await Promise.allSettled([updatePromise, ...messagePromises]);

      // 5. Log the results for monitoring.
      let successCount = 0;
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          if (index > 0) successCount++; // Don't count the DB update as a message
        } else {
          console.error(`CRON JOB: Failed to process reminder for donor ID ${donorIdsToUpdate[index - 1]}:`, result.reason);
        }
      });
      console.log(`CRON JOB: Successfully sent ${successCount} eligibility reminders.`);
      console.log(`CRON JOB: Updated ${donorIdsToUpdate.length} donors to 'available' status.`);

    } catch (error) {
      console.error('CRITICAL ERROR in cron job sendEligibilityReminders:', error);
    }
  }

  /**
   * Finds active, eligible donors who have not donated in a long time
   * and sends them a personalized re-engagement message.
   */
  async sendInactiveDonorNudges() {
    console.log('CRON JOB: Running Inactive Donor Nudge...');
    try {
      // 1. Find donors who are available but haven't donated in over 6 months (180 days).
      const { rows: inactiveDonors } = await db.query(
        `SELECT id, name, phone 
         FROM users
         WHERE 
           user_type = 'donor' AND
           availability_status = 'available' AND
           dnd_status = false AND
           (snooze_until IS NULL OR snooze_until < NOW()) AND
           (last_donation IS NULL OR last_donation < NOW() - INTERVAL '180 days')`
      );

      if (inactiveDonors.length === 0) {
        console.log('CRON JOB: No inactive donors to nudge this week.');
        return;
      }

      console.log(`CRON JOB: Found ${inactiveDonors.length} inactive donors. Sending nudges...`);
      for (const donor of inactiveDonors) {
        const nudgeMessage = `Hi ${donor.name}! We miss you. Patients in your area are still in need of heroes like you. We hope you'll consider donating again soon. Your support makes a huge difference!`;
        await whatsappService.sendTextMessage(donor.phone, nudgeMessage);
        // Add a small delay to avoid spamming the WhatsApp API
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    } catch (error) {
      console.error("CRITICAL ERROR in cron job sendInactiveDonorNudges:", error);
    }
  }
}

export default new EngagementService(); 

```

`backend/src/services/faqService.js`

```javascript
// backend/src/services/faqService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import mlService from './mlService.js';
import { GoogleGenerativeAI } from '@google/generative-ai'; // âœ… ADDED: Import Google AI SDK
import config from '../config/config.js'; // âœ… ADDED: Import config for API key

// âœ… ADDED: Initialize the generative model for dynamic answers
const genAI = new GoogleGenerativeAI(config.geminiApiKey);
const generativeModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" });

const SENSITIVE_KEYWORDS = ['problem', 'pain', 'issue', 'bad', 'reaction', 'scared', 'help me', 'confused', 'afraid'];

class FaqService {
  async handleFaq(query, phone) {
    const disclaimer = "\n\n_Disclaimer: This is automated information. For medical advice, please consult a doctor._";
    try {
      // 1. First, try the RAG system for a precise, pre-written answer.
      const ragResponse = await mlService.client.post('/generate-faq-answer', { query });

      if (ragResponse.data && ragResponse.data.source_found) {
        console.log(`RAG HIT: Found a precise answer for "${query}".`);
        await whatsappService.sendTextMessage(phone, ragResponse.data.answer + disclaimer);
        // We can stop here because we found a perfect answer.
        return;
      }

      // 2. âœ… NEW: If RAG fails, fallback to the generative model with live data.
      console.log(`RAG MISS: Falling back to generative model with live data for "${query}".`);
      
      let contextString = 'You are a helpful and compassionate assistant for BloodBridge AI. Answer the user\'s question concisely.';
      const lowerQuery = query.toLowerCase();

      // Check for keywords and inject live data into the context.
      if (lowerQuery.includes('patient') || lowerQuery.includes('support')) {
        const { rows } = await db.query("SELECT COUNT(*) as count FROM patients WHERE status = 'bridged'");
        const patientCount = rows[0].count;
        if (patientCount > 0) {
          contextString += ` IMPORTANT CONTEXT: We are currently supporting ${patientCount} long-term patients.`;
        }
      } else if (lowerQuery.includes('donor') || lowerQuery.includes('donors')) {
        const { rows } = await db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor' AND availability_status = 'available'");
        const donorCount = rows[0].count;
        if (donorCount > 0) {
          contextString += ` IMPORTANT CONTEXT: We have ${donorCount} active and eligible donors ready to help.`;
        }
      }
      
      // 3. Generate the dynamic answer using the context.
      const prompt = `${contextString}\n\nUser's Question: "${query}"`;
      const result = await generativeModel.generateContent(prompt);
      const response = await result.response;
      const aiText = response.text();

      await whatsappService.sendTextMessage(phone, aiText + disclaimer);

      // 4. Finally, check for sensitive keywords.
     if (SENSITIVE_KEYWORDS.some(keyword => lowerQuery.includes(keyword))) {
        console.log(`Sensitive keyword detected in "${query}". Escalating to admin inbox.`);
        await db.query( "INSERT INTO inbox_messages (user_phone, user_message, reason) VALUES ($1, $2, $3)", [phone, query, 'Sensitive Keyword Detected']);
        const escalationMessage = "It sounds like you might have a specific concern. I have notified an NGO volunteer, and they will contact you on this number shortly.";
        setTimeout(() => { whatsappService.sendTextMessage(phone, escalationMessage); }, 1500);
      }

    } catch (error) {
      console.error("Error calling FAQ service:", error.message);
      const fallbackMessage = "Thank you for your question. An NGO volunteer will get back to you shortly.";
      await whatsappService.sendTextMessage(phone, fallbackMessage);
    }
  }
}

export default new FaqService();

```

`backend/src/services/gamificationService.js`

```javascript
// backend/src/services/gamificationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

const ACHIEVEMENTS = {
  FIRST_REGISTRATION: { name: 'Community Hero', points: 50, emoji: 'â¤ï¸' },
  EMERGENCY_RESPONSE: { name: 'Life Saver', points: 100, emoji: 'ðŸš¨' },
};

class GamificationService {
   async awardPoints(userId, event, userPhone) {
    const achievement = ACHIEVEMENTS[event];
    if (!achievement) return;

    try {
      // Add points to the user's total score.
      const { rows: [user] } = await db.query(
        "UPDATE users SET gamification_points = gamification_points + $1 WHERE id = $2 RETURNING gamification_points",
        [achievement.points, userId]
      );

      if (!user) throw new Error("User not found or update failed.");

      // Log this specific achievement in the achievements table.
      await db.query(
        "INSERT INTO achievements(user_id, badge_type, points_awarded) VALUES($1, $2, $3)",
        [userId, achievement.name, achievement.points]
      );

      // Send a notification to the user.
      const notification = `ðŸ† Achievement Unlocked! ðŸ†\n\nYou've earned the *${achievement.name}* badge ${achievement.emoji} and received *${achievement.points} points*!\n\nYour new total is *${user.gamification_points} points*.`;
      await whatsappService.sendTextMessage(userPhone, notification);
    } catch (error) {
      console.error(`Error in awardPoints for user ${userId}:`, error);
    }
  } 

  /**
   * âœ… UPDATED: Fetches and formats a complete status report for a donor,
   * including their availability status.
   */
  async getDonorStatus(phone) {
    try {
      // Query now includes availability_status and cooldown_until
      const { rows: [user] } = await db.query(
        'SELECT id, name, gamification_points, last_donation, availability_status, cooldown_until FROM users WHERE phone = $1',
        [phone]
      );
      if (!user) {
        return "It looks like you're not registered as a donor yet. Reply with 'I want to register' to get started!";
      }
      
      const { rows: [rankData] } = await db.query(
        'SELECT count(*) FROM users WHERE user_type = \'donor\' AND gamification_points > $1',
        [user.gamification_points]
      );
      const rank = parseInt(rankData.count) + 1;

      // Format the availability status for the user
      let availabilityMessage = 'Available âœ…';
      if (user.availability_status === 'unavailable' && user.cooldown_until) {
        const cooldownDate = new Date(user.cooldown_until).toLocaleDateString('en-IN');
        availabilityMessage = `On Cooldown until ${cooldownDate} â³`;
      } else if (user.availability_status !== 'available') {
        availabilityMessage = 'Not Available âŒ';
      }

      let statusMessage = `*ðŸ“Š Your Donor Dashboard ðŸ“Š*\n\n`;
      statusMessage += `*Name:* ${user.name}\n`;
      statusMessage += `*Status:* ${availabilityMessage}\n`; // Add the status line
      statusMessage += `*Points:* ${user.gamification_points} ðŸ…\n`;
      statusMessage += `*Current Rank:* #${rank} of all our heroes\n`;
      statusMessage += `*Last Donation:* ${user.last_donation ? new Date(user.last_donation).toLocaleDateString('en-IN') : 'N/A'}`;
      
      return statusMessage;
    } catch (error) {
      console.error(`Error in getDonorStatus for phone ${phone}:`, error);
      return "Sorry, I couldn't fetch your status at this time. Please try again later.";
    }
  }

  /**
   * âœ… UPDATED: Fetches the Top 5 donors AND the requesting user's rank.
   */
  async getLeaderboardMessage(phone) {
    try {
      // Query 1: Get the Top 5 donors
      const { rows: topDonors } = await db.query(
        `SELECT name, gamification_points FROM users 
         WHERE user_type = 'donor' AND gamification_points > 0
         ORDER BY gamification_points DESC LIMIT 5`
      );

      if (topDonors.length === 0) {
        return "The leaderboard is empty right now, but the next donation could change that!";
      }

      // Query 2: Get the current user's rank
      const { rows: [userRankData] } = await db.query(
        `SELECT count(*) FROM users WHERE user_type = 'donor' AND gamification_points > (
           SELECT gamification_points FROM users WHERE phone = $1
         )`,
        [phone]
      );
      const userRank = parseInt(userRankData.count) + 1;

      // Format the message
      let leaderboardMessage = "ðŸ† *Top 5 Blood Warriors* ðŸ†\n\n";
      const medals = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', '4.', '5.'];
      topDonors.forEach((donor, index) => {
        leaderboardMessage += `${medals[index]} *${donor.name}* (${donor.gamification_points} points)\n`;
      });
      leaderboardMessage += `\n*Your Rank:* #${userRank}`;

      return leaderboardMessage;
    } catch (error) {
      console.error('Error fetching leaderboard for chatbot:', error);
      return "Sorry, I couldn't fetch the leaderboard right now.";
    }
  }
}

export default new GamificationService();

```

`backend/src/services/geocodingService.js`

```javascript
// backend/src/services/geocodingService.js
import axios from 'axios';

class GeocodingService {
    async getCoords(address, city, pincode) {
        if (!address && !pincode) return null;
        const query = `${address || ''}, ${city || ''}, ${pincode || ''}`;
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
        try {
            const response = await axios.get(url, {
                headers: { 'User-Agent': 'BloodBridgeAI/1.0 (tech@bloodbridge.org)' }
            });
            if (response.data && response.data.length > 0) {
                const { lat, lon } = response.data[0];
                return { latitude: parseFloat(lat), longitude: parseFloat(lon) };
            }
            return null;
        } catch (error) {
            console.error('Error calling Geocoding API:', error.message);
            return null;
        }
    }
}

export default new GeocodingService();

```

`backend/src/services/loggingService.js`

```javascript
// backend/src/services/loggingService.js
import db from '../config/db.js';

class LoggingService {
  /**
   * Logs an incoming message and now includes the user's phone number directly.
   */
  async logIncoming(phone, message) {
    try {
      // Find the user's ID to maintain the relationship, but also store the phone number.
      const { rows: [user] } = await db.query(
        'SELECT id FROM users WHERE phone = $1',
        [phone]
      );
      const userId = user ? user.id : null;

      // Insert the incoming message, user_id, and the user_phone into the table.
      await db.query(
        'INSERT INTO conversations (user_id, user_phone, message) VALUES ($1, $2, $3)',
        [userId, phone, message]
      );
    } catch (error) {
      console.error('Error logging incoming message to DB:', error);
    }
  }

  /**
   * Logs an outgoing message by finding the last message from a specific phone number.
   */
  async logOutgoing(phone, response) {
    try {
      // Find the last conversation from this user's phone number that doesn't have a response yet
      // and update it with the bot's reply. This is more direct than looking up the user ID first.
      await db.query(
        `UPDATE conversations 
         SET response = $1 
         WHERE id = (
           SELECT id FROM conversations 
           WHERE user_phone = $2 AND response IS NULL 
           ORDER BY created_at DESC 
           LIMIT 1
         )`,
        [response, phone]
      );
    } catch (error) {
      console.error('Error logging outgoing message to DB:', error);
    }
  }
}

export default new LoggingService();

```

`backend/src/services/mlService.js`

```javascript
// backend/src/services/mlService.js
import axios from 'axios';
import db from '../config/db.js';
import config from '../config/config.js';

const CACHE_DURATION_HOURS = 6;

class MLService {
    constructor() {
        this.client = axios.create({
            baseURL: config.mlServiceUrl,
            timeout: 8000,
        });
    }

    /**
     * Scores a single donor, using a cached score if available and not stale.
     */
    async scoreSingleDonor(donor) {
        // Check for a fresh score in the cache first.
        const { rows: [cachedData] } = await db.query(
            "SELECT last_ml_score, score_cached_at FROM users WHERE id = $1",
            [donor.id]
        );

        if (cachedData && cachedData.last_ml_score && cachedData.score_cached_at) {
            const cacheAgeHours = (new Date() - new Date(cachedData.score_cached_at)) / (1000 * 60 * 60);
            if (cacheAgeHours < CACHE_DURATION_HOURS) {
                console.log(`CACHE HIT: Using cached score for donor ${donor.id}`);
                return { final_score: cachedData.last_ml_score };
            }
        }

        console.log(`CACHE MISS: Calling ML service for donor ${donor.id}`);
        try {
            // If no fresh cache, call the Python ML service.
            const response = await this.client.post('/score-donor', {
                donor_id: donor.id,
                last_donation_date: donor.last_donation,
                streak_count: donor.streak_count || 0,
                notifications_received: donor.notifications_received || 0,
                donations_confirmed: donor.donations_confirmed || 0
            });
            
            const newScore = response.data.final_score;

            // Update the cache in the database with the new score.
            db.query(
                "UPDATE users SET last_ml_score = $1, score_cached_at = NOW() WHERE id = $2",
                [newScore, donor.id]
            ).catch(err => console.error(`Failed to cache ML score for donor ${donor.id}:`, err));

            return { final_score: newScore };

        } catch (error) {
            console.error(`ðŸ”´ ML Service Error for donor ${donor.id}:`, error.message);
            throw error; // Re-throw the error to be handled by the calling service.
        }
    }
}

export default new MLService();

```

`backend/src/services/patientService.js`

```javascript
// backend/src/services/patientService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class PatientService {
  /**
   * Handles the initial message from a potential patient.
   * Creates a pending record and asks them to opt-in by replying "APPLY".
   */
  async handleNewPatient(params, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingPatient] } = await db.query("SELECT id FROM patients WHERE phone = $1", [sanitizedPhone]);
      if (existingPatient) {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back! Our records show this number is already associated with a patient. An admin will be in touch shortly.`);
        return;
      }

      const { patient_name, city, blood_group } = params;

      // PATH 1: AI extracted details for a one-shot registration (Passes REG-04)
      if (patient_name && city && blood_group) {
        const normalizedBG = normalizeBloodGroup(blood_group);
        await db.query(
          `INSERT INTO patients (name, phone, blood_group, city, status)
           VALUES ($1, $2, $3, $4, 'pending_verification')`,
          [patient_name, sanitizedPhone, normalizedBG, city]
        );
        const finalMessage = `Thank you! We have received the initial information for *${patient_name}*.\n\nAn admin from our team has been notified and will contact you on this number to verify the details.`;
        await whatsappService.sendTextMessage(sanitizedPhone, finalMessage);
      } 
      // PATH 2: Details are missing, fall back to the conversational flow.
      else {
        await db.query(
          `INSERT INTO patients (name, phone, blood_group, city, status)
           VALUES ('Awaiting Input', $1, 'N/A', 'N/A', 'pending_opt_in') ON CONFLICT (phone) DO NOTHING;`,
          [sanitizedPhone]
        );
        await whatsappService.sendTextMessage(sanitizedPhone, `Thank you for reaching out. To begin your application for our Blood Bridge support program, please reply with: *APPLY*`);
      }
    } catch (error) {
      console.error('Error in handleNewPatient:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'Sorry, we encountered an error logging your request.');
    }
  }
  
  
  /**
   * Starts the conversational form after the user replies "APPLY".
   */
  async startApplication(phone) {
      const { rows: [patient] } = await db.query("SELECT id FROM patients WHERE phone = $1 AND status = 'pending_opt_in'", [phone]);
      if (!patient) return false;

      await db.query("UPDATE patients SET status = 'pending_details' WHERE id = $1", [patient.id]);
      await this.continueOnboarding(patient.id, phone);
      return true;
  }

  /**
   * The "state machine" that asks the next question based on what info is missing.
   */
  async continueOnboarding(patientId, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE id = $1", [patientId]);
    if (!patient) return;

    if (patient.name === 'Awaiting Input') {
      await whatsappService.sendTextMessage(phone, "Great! Let's begin.\n\nFirst, what is the patient's full name?");
      return;
    }
    if (patient.blood_group === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Thank you. What is ${patient.name}'s blood group? (e.g., O+, AB-)`);
      return;
    }
    if (patient.city === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Got it. In which city does the patient receive treatment?`);
      return;
    }

    // All details are collected.
    await db.query("UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    const finalMessage = `Thank you! We have all the initial information we need for *${patient.name}*.\n\nAn admin has been notified and will contact you on this number to verify the details.`;
    await whatsappService.sendTextMessage(phone, finalMessage);
  }

  /**
   * Processes a user's reply during the conversational form.
   */
  async processOnboardingReply(message, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE phone = $1 AND status = 'pending_details'", [phone]);
    if (!patient) return false;

    let columnToUpdate = null;
    let valueToUpdate = message;
    
    if (patient.name === 'Awaiting Input') columnToUpdate = 'name';
    else if (patient.blood_group === 'N/A') {
      columnToUpdate = 'blood_group';
      valueToUpdate = normalizeBloodGroup(message);
    } else if (patient.city === 'N/A') columnToUpdate = 'city';
    
    if (columnToUpdate) {
        await db.query(`UPDATE patients SET ${columnToUpdate} = $1 WHERE id = $2`, [valueToUpdate, patient.id]);
        
        // Ask the next question after a short delay
        setTimeout(() => { this.continueOnboarding(patient.id, phone); }, 500);
        return true;
    }
    return false;
  }
}

export default new PatientService();

```

`backend/src/services/registrationService.js`

```javascript
// backend/src/services/registrationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import gamificationService from './gamificationService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';

class RegistrationService {
  /**
   * âœ… REWRITTEN: A single, intelligent function to handle all donor registration.
   */
    async handleNewDonor(params, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingUser] } = await db.query(
        "SELECT id, name, registration_status FROM users WHERE phone = $1", 
        [sanitizedPhone]
      );

      if (existingUser && existingUser.registration_status === 'completed') {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back, ${existingUser.name}! You are already registered.`);
        return;
      }

      const { name, city, blood_group } = params;

      // CASE 1: The AI successfully extracted the details from the user's message.
      if (name && name !== 'Unknown' && city && city !== 'Unknown' && blood_group && blood_group !== 'Unknown') {
        const normalizedBG = normalizeBloodGroup(blood_group);
        
        const { rows: [newUser] } = await db.query(
          `INSERT INTO users(name, city, blood_group, phone, user_type, registration_status, role)
           VALUES($1, $2, $3, $4, 'donor', 'completed', 'Emergency Donor')
           ON CONFLICT (phone) DO UPDATE SET 
             name = EXCLUDED.name, city = EXCLUDED.city, blood_group = EXCLUDED.blood_group, 
             registration_status = 'completed', role = 'Emergency Donor'
           RETURNING *;`,
          [name.trim(), city.trim(), normalizedBG, sanitizedPhone]
        );

        const successMessage = `âœ… Registration Complete!\n\nWelcome, ${newUser.name}! You are now a registered Blood Warrior in ${newUser.city}.`;
        await whatsappService.sendTextMessage(sanitizedPhone, successMessage);
        await gamificationService.awardPoints(newUser.id, 'FIRST_REGISTRATION', sanitizedPhone);

        // âœ… NEW LOGIC: Send the interactive prompt to join a bridge.
        const bridgeQuestion = `Would you like to join a "Blood Bridge"?\n\nThis is a dedicated group of donors who support a specific patient with regular transfusions.`;
        const buttons = [
            { id: `join_bridge_${newUser.id}`, title: "Yes, sign me up!" },
            { id: `decline_bridge_${newUser.id}`, title: "Maybe later" }
        ];
        
        // Use a small delay so messages arrive in the correct order
        setTimeout(() => {
            whatsappService.sendInteractiveMessage(sanitizedPhone, bridgeQuestion, buttons);
        }, 1500); // 1.5 second delay

        return;
      }

      // CASE 2: The AI determined the user wants to register but couldn't find the details.
      const followupMessage = 
        "Great! To get you registered as a donor, please reply with your Name, City, and Blood Group.";
      
      await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);

    } catch (error) {
      console.error('Critical error in handleNewDonor:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'We encountered an error during registration.');
    }
  }
}

export default new RegistrationService();

```

`backend/src/services/responseService.js`

```javascript
// backend/src/services/responseService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateOTP } from '../utils/otpHelper.js';
import gamificationService from './gamificationService.js';
import bridgeService from './bridgeService.js';
import BridgeCoordinationService from './bridgeCoordinationService.js';

class ResponseService {
    /**
     * Handles the donor's initial reply (e.g., "YES 1234").
     * It validates the code and sends back a 6-digit OTP to verify.
     */
    async handleDonorReplyWithShortCode(donorPhone, shortCode) {
        try {
            const { rows: [request] } = await db.query(`SELECT id FROM emergency_requests WHERE short_code = $1 AND status = 'active'`, [shortCode]);
            if (!request) {
                await whatsappService.sendTextMessage(donorPhone, `Sorry, we couldn't find an active request with code ${shortCode}. It may have been fulfilled.`);
                return;
            }

            const { rows: [user] } = await db.query(`SELECT id FROM users WHERE phone = $1`, [donorPhone]);
            if (!user) {
                await whatsappService.sendTextMessage(donorPhone, "We couldn't find your registration. Please register first.");
                return;
            }

            const otp = generateOTP();
            await db.query(
                `INSERT INTO donor_responses (donor_id, request_id, response, otp, otp_expires_at)
                 VALUES ($1, $2, 'pending', $3, NOW() + INTERVAL '10 minutes')
                 ON CONFLICT (donor_id, request_id) DO UPDATE SET response = 'pending', otp = $3, otp_expires_at = NOW() + INTERVAL '10 minutes';`,
                [user.id, request.id, otp]
            );

            const otpMessage = `Thank you for your quick response! To finalize your confirmation, please reply with *only* the following 6-digit code:\n\n*${otp}*`;
            await whatsappService.sendTextMessage(donorPhone, otpMessage);
        } catch (error) {
            console.error('Error in handleDonorReplyWithShortCode:', error);
            await whatsappService.sendTextMessage(donorPhone, "There was a system error processing your reply.");
        }
    }

    /**
     * Verifies the 6-digit OTP and finalizes the donation confirmation.
     * This function uses a database transaction to ensure all updates succeed or none do.
     */

      async handleSimpleDecline(donorPhone) {
    try {
      const { rows: [user] } = await db.query('SELECT id FROM users WHERE phone = $1', [donorPhone]);
      if (!user) return; // User not registered, do nothing.

      // Find the last active request this donor was notified for.
      const { rows: [lastRequest] } = await db.query(
        `SELECT r.id FROM emergency_requests r 
         JOIN donor_responses dr ON r.id = dr.request_id
         WHERE dr.donor_id = $1 AND r.status = 'active' AND dr.response = 'pending'
         ORDER BY dr.created_at DESC LIMIT 1;`,
        [user.id]
      );
      
      if (lastRequest) {
        // Mark their response as 'declined'.
        await db.query(
          "UPDATE donor_responses SET response = 'declined' WHERE donor_id = $1 AND request_id = $2",
          [user.id, lastRequest.id]
        );
        
        await whatsappService.sendTextMessage(donorPhone, "Thank you for letting us know. We will contact the next available donor immediately.");
        
        // Immediately trigger the escalation to the next batch.
        emergencyService.findNextDonorForRequest(lastRequest.id);
      } else {
        await whatsappService.sendTextMessage(donorPhone, "Thank you for your response. There are no active requests pending for you at this moment.");
      }
    } catch (error) {
      console.error("Error handling simple decline:", error);
    }
  }
    // In responseService.js
async verifyOTPAndConfirm(donorPhone, otp) {
    const client = await db.pool.connect();
    try {
        await client.query('BEGIN');

        const { rows: [response] } = await client.query(
            // Add request_type and bridge_id to the SELECT statement
            `SELECT dr.id, dr.request_id, u.name as donor_name, u.id as donor_id, 
                    er.patient_name, er.requested_by_phone, er.request_type, er.bridge_id
             FROM donor_responses dr JOIN users u ON dr.donor_id = u.id JOIN emergency_requests er ON dr.request_id = er.id
             WHERE u.phone = $1 AND dr.otp = $2 AND dr.otp_expires_at > NOW() AND dr.response = 'pending' FOR UPDATE;`,
            [donorPhone, otp]
        );

        if (!response) {
            await whatsappService.sendTextMessage(donorPhone, "Invalid or expired OTP. Please try the 'YES [code]' step again.");
            await client.query('ROLLBACK');
            return;
        }

        // Perform all database updates
        await client.query(`UPDATE users SET last_donation = NOW(), availability_status = 'unavailable', cooldown_until = NOW() + INTERVAL '90 days', donations_confirmed = donations_confirmed + 1, streak_count = streak_count + 1 WHERE id = $1`, [response.donor_id]);
        await client.query("UPDATE donor_responses SET response = 'accepted', confirmed_at = NOW(), otp = NULL WHERE id = $1", [response.id]);
        await client.query("UPDATE emergency_requests SET status = 'fulfilled' WHERE id = $1", [response.request_id]);
        
        // --- NEW LOGIC: ROTATE THE BRIDGE IF APPLICABLE ---
        // We pass the active transaction client to the rotation function
        if (response.request_type === 'bridge' && response.bridge_id) {
            await bridgeCoordinationService.rotateBridge(response.bridge_id, client);
        }
        // --- END NEW LOGIC ---

        await client.query('COMMIT');

        // Send confirmations and award points
        const donorConfirmationMessage = `âœ… Confirmed! Thank you, ${response.donor_name}!\n\nYour donation for *${response.patient_name}* is confirmed. Please coordinate with the hospital. You are a true hero!`;
        await whatsappService.sendTextMessage(donorPhone, donorConfirmationMessage);

        if (response.requested_by_phone && response.requested_by_phone !== 'system') {
            const requesterUpdate = `âœ… Good News! A donor has been confirmed for your request for *${response.patient_name}*.`;
            await whatsappService.sendTextMessage(response.requested_by_phone, requesterUpdate);
        }
        gamificationService.awardPoints(response.donor_id, 'EMERGENCY_RESPONSE', donorPhone);

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("Error verifying OTP:", error);
        await whatsappService.sendTextMessage(donorPhone, "A system error occurred during OTP verification.");
    } finally {
        client.release();
    }
}
}

export default new ResponseService();

```

`backend/src/services/schedulerService.js`

```javascript
// backend/src/services/schedulerService.js
import cron from 'node-cron';
// âœ… FIX: Import the already-created INSTANCES of the services
import engagementService from './engagementService.js';
import bridgeCoordinationService from './bridgeCoordinationService.js';

// âœ… FIX: Use the imported instances directly in these functions
export const triggerEligibilityReminders = () => {
  console.log('MANUAL TRIGGER: Running eligibility reminders...');
  return engagementService.sendEligibilityReminders();
};

export const triggerAutomaticBridgeRequests = () => {
  console.log('MANUAL TRIGGER: Running automatic bridge requests...');
  return bridgeCoordinationService.triggerAutomaticBridgeRequests();
};

export const triggerInactiveDonorNudges = () => {
  console.log('MANUAL TRIGGER: Running inactive donor nudges...');
  return engagementService.sendInactiveDonorNudges();
};

class SchedulerService {
  start() {
    console.log('ðŸ•’ Cron job for eligibility reminders scheduled to run every day at 9:00 AM.');
    cron.schedule('0 9 * * *', triggerEligibilityReminders, { timezone: "Asia/Kolkata" });
    
    console.log('ðŸ•’ Cron job for automatic bridge requests scheduled to run every day at 8:00 AM.');
    cron.schedule('0 8 * * *', triggerAutomaticBridgeRequests, { timezone: "Asia/Kolkata" });
    
    console.log('ðŸ•’ Cron job for inactive donor nudges scheduled to run every Sunday at 10:00 AM.');
    cron.schedule('0 10 * * 0', triggerInactiveDonorNudges, { timezone: "Asia/Kolkata" });
  }
}

export const Scheduler = new SchedulerService();

```

`backend/src/services/whatsappService.js`

```javascript
// backend/src/services/whatsappService.js
import axios from 'axios';
import config from '../config/config.js';
import loggingService from './loggingService.js';

class WhatsAppService {
  constructor() {
    this.token = config.whatsappToken;
    this.phoneNumberId = config.whatsappPhoneNumberId;
    if (!this.token || !this.phoneNumberId) {
      console.warn('WhatsApp token or Phone Number ID are missing. Messages will not be sent.');
    }

    this.client = axios.create({
      baseURL: `https://graph.facebook.com/v18.0/${this.phoneNumberId}`,
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json'
      }
    });
  }
  async sendTextMessage(to, text) {
    if (!this.token) return { success: false, error: "WhatsApp service not configured." };

    const payload = {
      messaging_product: 'whatsapp',
      to: to,
      type: 'text',
      text: { body: text }
    };

    try {
      const response = await this.client.post('/messages', payload);
      
      // âœ… MODIFIED LINE: This now prints the message content to the console.
      console.log(`âœ… Message sent to ${to}: "${text}"`);
      
      await loggingService.logOutgoing(to, text);
      return { success: true, data: response.data };
    } catch (error) {
      console.error(`ðŸ”´ FAILED to send message to ${to}.`);
      if (error.response) {
        console.error(`Error Details: ${error.response.data.error?.message}`);
      }
      return { success: false, error: error.message };
    }
  }

    /**
   * âœ… NEW FUNCTION
   * Sends an interactive message with reply buttons.
   * @param {string} to - The recipient's phone number.
   * @param {string} text - The message body.
   * @param {Array<object>} buttons - Array of button objects, e.g., [{ id: '1', title: 'Yes' }]
   */
  async sendInteractiveMessage(to, text, buttons) {
    if (!this.token) return { success: false, error: "WhatsApp service not configured." };

    const payload = {
      messaging_product: 'whatsapp',
      to: to,
      type: 'interactive',
      interactive: {
        type: 'button',
        body: { text: text },
        action: {
          buttons: buttons.map(btn => ({
            type: 'reply',
            reply: { id: btn.id, title: btn.title }
          }))
        }
      }
    };
    
    try {
      const response = await this.client.post('/messages', payload);
      console.log(`âœ… Interactive message sent to ${to}: "${text}"`);
      await loggingService.logOutgoing(to, text); // Also log this message
      return { success: true, data: response.data };
    } catch (error) {
      console.error(`ðŸ”´ FAILED to send interactive message to ${to}.`);
      if (error.response) {
        console.error(`Error Details: ${error.response.data.error?.message}`);
      }
      return { success: false, error: error.message };
    }
  }

}

export default new WhatsAppService();

```

`backend/src/utils/dataSanitizer.js`

```javascript
// backend/src/utils/dataSanitizer.js
export const normalizeBloodGroup = (group) => {
  if (!group) return 'Unknown';
  
  // âœ… ADD THIS CHECK: Return 'Unknown' immediately if that's the input.
  if (group.toUpperCase() === 'UNKNOWN') {
    return 'Unknown';
  }

  const upperGroup = group.toUpperCase();
  let normalized = upperGroup.replace(/\s/g, '').replace('POSITIVE', '+').replace('NEGATIVE', '-');
  if (normalized.endsWith('POS')) normalized = normalized.replace('POS', '+');
  if (normalized.endsWith('NEG')) normalized = normalized.replace('NEG', '-');
  return normalized.slice(0, 5);
};

```

`backend/src/utils/distanceHelper.js`

```javascript
// backend/src/utils/distanceHelper.js
/**
 * Calculates distance between two lat/lng points in km using the Haversine formula.
 */
export const getDistanceInKm = (lat1, lon1, lat2, lon2) => {
    if ((lat1 == lat2) && (lon1 == lon2)) {
        return 0;
    }
    const R = 6371; // Radius of the earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        0.5 - Math.cos(dLat) / 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        (1 - Math.cos(dLon)) / 2;
    return R * 2 * Math.asin(Math.sqrt(a));
};

```

`backend/src/utils/languageHelper.js`

```javascript
// backend/src/utils/languageHelper.js
import { franc } from 'franc';

// This utility uses a lightweight library to guess the language of a message.
export async function detectLanguage(text) {
  try {
    // franc returns a 3-letter ISO 639-3 code. 'und' means undetermined.
    const langCode = franc(text);
    if (langCode === 'und') {
      return null; // Could not determine language
    }
    // Map common 3-letter codes to 2-letter codes for simplicity
    const langMap = {
        'eng': 'en',
        'hin': 'hi', // Hindi
        'tel': 'te'  // Telugu
    };
    return langMap[langCode] || null;
  } catch (error) {
    console.error("Language detection error:", error);
    return null;
  }
}

```

`backend/src/utils/otpHelper.js`

```javascript
// backend/src/utils/otpHelper.js

/**
 * Generates a 4-digit numeric code for donors to reply with.
 * @returns {string} A 4-digit string.
 */
export const generateShortCode = () => {
  return Math.floor(1000 + Math.random() * 9000).toString();
};

/**
 * Generates a 6-digit numeric OTP for final confirmation.
 * @returns {string} A 6-digit string.
 */
export const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

```

`backend/src/utils/phoneHelper.js`

```javascript
// backend/src/utils/phoneHelper.js
export const normalizePhoneNumber = (phone) => {
  if (!phone || typeof phone !== 'string') return null;
  let digits = phone.replace(/\D/g, '');
  if (digits.startsWith('91') && digits.length === 12) {
    return `+${digits}`;
  } else if (digits.length === 10) {
    return `+91${digits}`;
  }
  return `+${digits}`;
};

```

`backend/src/utils/translationService.js`

```javascript
// backend/src/services/translationService.js
// In a real application, this would connect to a service like Google Translate.
// For this project, we are mocking the translation for a few specific phrases.
class TranslationService {
  async translateToEnglish(text) {
    if (text.includes("à¤•à¥ˆà¤¸à¥‡ à¤ªà¤‚à¤œà¥€à¤•à¤°à¤£") || text.includes("à¤°à¤•à¥à¤¤à¤¦à¤¾à¤¨ à¤•à¥ˆà¤¸à¥‡ à¤•à¤°à¥‡à¤‚")) {
      console.log('Translation Mock: Detected Hindi registration query.');
      return "How can I register to donate blood?";
    }
    if (text.includes("à°¨à°®à±‹à°¦à±") || text.includes("à°Žà°²à°¾ à°¨à°®à±‹à°¦à±")) {
        console.log('Translation Mock: Detected Telugu registration query.');
        return "How can I register to donate blood?";
    }
    // If no match is found, return the original text.
    return text;
  }
}

export default new TranslationService();

```

`code.txt`

```

```

`db.txt`

```
-- WARNING: This schema is for context only and is not meant to be run.
-- Table order and constraints may not be valid for execution.

CREATE TABLE public.achievements (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid,
  badge_type character varying NOT NULL,
  points_awarded integer DEFAULT 0 CHECK (points_awarded >= 0),
  earned_at timestamp with time zone DEFAULT now(),
  CONSTRAINT achievements_pkey PRIMARY KEY (id),
  CONSTRAINT achievements_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id)
);
CREATE TABLE public.blood_bridges (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  patient_id uuid,
  name character varying NOT NULL,
  blood_group character varying NOT NULL CHECK (blood_group::text = ANY (ARRAY['A+'::character varying, 'A-'::character varying, 'B+'::character varying, 'B-'::character varying, 'O+'::character varying, 'O-'::character varying, 'AB+'::character varying, 'AB-'::character varying]::text[])),
  city character varying NOT NULL,
  rotation_position integer DEFAULT 1 CHECK (rotation_position >= 1),
  active boolean DEFAULT true,
  created_at timestamp with time zone DEFAULT now(),
  active_request_id uuid,
  CONSTRAINT blood_bridges_pkey PRIMARY KEY (id),
  CONSTRAINT blood_bridges_patient_id_fkey FOREIGN KEY (patient_id) REFERENCES public.patients(id),
  CONSTRAINT blood_bridges_active_request_id_fkey FOREIGN KEY (active_request_id) REFERENCES public.emergency_requests(id)
);
CREATE TABLE public.bridge_members (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  bridge_id uuid,
  donor_id uuid,
  position integer NOT NULL CHECK ("position" >= 0),
  status character varying NOT NULL DEFAULT 'active'::character varying CHECK (status::text = ANY (ARRAY['active'::character varying, 'inactive'::character varying, 'skipped'::character varying]::text[])),
  joined_at timestamp with time zone DEFAULT now(),
  rotation_order integer,
  CONSTRAINT bridge_members_pkey PRIMARY KEY (id),
  CONSTRAINT bridge_members_donor_id_fkey FOREIGN KEY (donor_id) REFERENCES public.users(id),
  CONSTRAINT bridge_members_bridge_id_fkey FOREIGN KEY (bridge_id) REFERENCES public.blood_bridges(id)
);
CREATE TABLE public.conversations (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid,
  message text NOT NULL,
  response text,
  created_at timestamp with time zone DEFAULT now(),
  user_phone character varying,
  CONSTRAINT conversations_pkey PRIMARY KEY (id),
  CONSTRAINT conversations_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id)
);
CREATE TABLE public.donor_responses (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  donor_id uuid,
  request_id uuid,
  response character varying NOT NULL CHECK (response::text = ANY (ARRAY['pending'::character varying, 'accepted'::character varying, 'declined'::character varying]::text[])),
  otp character varying,
  otp_expires_at timestamp with time zone,
  confirmed_at timestamp with time zone,
  created_at timestamp with time zone DEFAULT now(),
  CONSTRAINT donor_responses_pkey PRIMARY KEY (id),
  CONSTRAINT donor_responses_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.emergency_requests(id),
  CONSTRAINT donor_responses_donor_id_fkey FOREIGN KEY (donor_id) REFERENCES public.users(id)
);
CREATE TABLE public.emergency_requests (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  patient_name character varying NOT NULL,
  blood_group character varying NOT NULL CHECK (blood_group::text = ANY (ARRAY['A+'::character varying, 'A-'::character varying, 'B+'::character varying, 'B-'::character varying, 'O+'::character varying, 'O-'::character varying, 'AB+'::character varying, 'AB-'::character varying]::text[])),
  units_needed integer NOT NULL CHECK (units_needed > 0),
  hospital_name character varying NOT NULL,
  hospital_contact character varying,
  city character varying NOT NULL,
  urgency_level character varying DEFAULT 'high'::character varying CHECK (urgency_level::text = ANY (ARRAY['critical'::character varying, 'high'::character varying, 'medium'::character varying]::text[])),
  status character varying DEFAULT 'active'::character varying CHECK (status::text = ANY (ARRAY['active'::character varying, 'fulfilled'::character varying, 'closed'::character varying, 'escalated'::character varying]::text[])),
  created_by uuid,
  requested_by_phone character varying NOT NULL,
  short_code character varying UNIQUE,
  units_confirmed integer DEFAULT 0 CHECK (units_confirmed >= 0),
  created_at timestamp with time zone DEFAULT now(),
  fulfilled_at timestamp with time zone,
  request_type character varying DEFAULT 'standard'::character varying CHECK (request_type::text = ANY (ARRAY['standard'::character varying, 'bridge'::character varying]::text[])),
  bridge_id uuid,
  latitude real,
  longitude real,
  patient_id uuid,
  CONSTRAINT emergency_requests_pkey PRIMARY KEY (id),
  CONSTRAINT emergency_requests_bridge_id_fkey FOREIGN KEY (bridge_id) REFERENCES public.blood_bridges(id),
  CONSTRAINT emergency_requests_patient_id_fkey FOREIGN KEY (patient_id) REFERENCES public.patients(id),
  CONSTRAINT emergency_requests_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id)
);
CREATE TABLE public.inbox_messages (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_phone character varying NOT NULL,
  user_message text NOT NULL,
  reason character varying NOT NULL,
  status character varying DEFAULT 'pending'::character varying CHECK (status::text = ANY (ARRAY['pending'::character varying, 'resolved'::character varying]::text[])),
  created_at timestamp with time zone DEFAULT now(),
  resolved_at timestamp with time zone,
  CONSTRAINT inbox_messages_pkey PRIMARY KEY (id)
);
CREATE TABLE public.knowledge_base (
  id integer NOT NULL DEFAULT nextval('knowledge_base_id_seq'::regclass),
  content text NOT NULL,
  category character varying,
  embedding jsonb,
  CONSTRAINT knowledge_base_pkey PRIMARY KEY (id)
);
CREATE TABLE public.patients (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name character varying NOT NULL,
  phone character varying NOT NULL UNIQUE,
  blood_group character varying NOT NULL CHECK (blood_group::text = ANY (ARRAY['A+'::text, 'A-'::text, 'B+'::text, 'B-'::text, 'O+'::text, 'O-'::text, 'AB+'::text, 'AB-'::text, 'N/A'::text])),
  city character varying NOT NULL,
  pincode character varying,
  condition text,
  status character varying DEFAULT 'pending'::character varying CHECK (status::text = ANY (ARRAY['pending'::character varying, 'pending_opt_in'::character varying, 'pending_details'::character varying, 'pending_verification'::character varying, 'bridged'::character varying, 'active'::character varying]::text[])),
  last_transfusion_date date,
  frequency_in_days integer CHECK (frequency_in_days > 0),
  quantity_required integer DEFAULT 1 CHECK (quantity_required > 0),
  created_at timestamp with time zone DEFAULT now(),
  user_id uuid,
  CONSTRAINT patients_pkey PRIMARY KEY (id),
  CONSTRAINT patients_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id)
);
CREATE TABLE public.processed_messages (
  message_id character varying NOT NULL,
  processed_at timestamp with time zone DEFAULT now(),
  payload jsonb,
  CONSTRAINT processed_messages_pkey PRIMARY KEY (message_id)
);
CREATE TABLE public.schema_migrations (
  version character varying NOT NULL,
  applied_at timestamp with time zone DEFAULT now(),
  description text,
  CONSTRAINT schema_migrations_pkey PRIMARY KEY (version)
);
CREATE TABLE public.users (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  phone character varying NOT NULL UNIQUE,
  name character varying NOT NULL,
  password character varying,
  blood_group character varying CHECK (blood_group::text = ANY (ARRAY['A+'::character varying, 'A-'::character varying, 'B+'::character varying, 'B-'::character varying, 'O+'::character varying, 'O-'::character varying, 'AB+'::character varying, 'AB-'::character varying, 'Unknown'::character varying]::text[])),
  city character varying,
  pincode character varying,
  user_type character varying NOT NULL CHECK (user_type::text = ANY (ARRAY['donor'::character varying, 'patient'::character varying, 'admin'::character varying]::text[])),
  role character varying DEFAULT 'Emergency Donor'::character varying,
  registration_status character varying DEFAULT 'completed'::character varying CHECK (registration_status::text = ANY (ARRAY['pending'::character varying, 'completed'::character varying]::text[])),
  availability_status character varying DEFAULT 'available'::character varying CHECK (availability_status::text = ANY (ARRAY['available'::character varying, 'unavailable'::character varying, 'on_hold'::character varying]::text[])),
  dnd_status boolean DEFAULT false,
  snooze_until timestamp with time zone,
  cooldown_until timestamp with time zone,
  last_donation date,
  donations_till_date integer DEFAULT 0 CHECK (donations_till_date >= 0),
  gamification_points integer DEFAULT 0 CHECK (gamification_points >= 0),
  streak_count integer DEFAULT 0 CHECK (streak_count >= 0),
  last_ml_score real,
  score_cached_at timestamp with time zone,
  last_request_short_code character varying,
  quiet_hours_start time without time zone,
  quiet_hours_end time without time zone,
  inactive_trigger_comment text,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  notifications_received integer DEFAULT 0 CHECK (notifications_received >= 0),
  donations_confirmed integer DEFAULT 0 CHECK (donations_confirmed >= 0),
  latitude real,
  longitude real,
  CONSTRAINT users_pkey PRIMARY KEY (id)
);

```

`dummy.js`

```javascript


```

`ml_services/.env`

```
# ml_services/.env

# This should be the same database URL used in your backend/.env file.
DATABASE_URL="postgresql://postgres.psussvygzgzkkwdjqbwp:asdfusahdfuu3842r7gdsfh@aws-1-ap-southeast-1.pooler.supabase.com:6543/postgres"
GEMINI_API_KEY="AIzaSyAvPuLpiCRezLDdJZt9eqW67vt1_BrG92w"

```

`ml_services/main.py`

```python
# ml_services/main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional
from datetime import datetime
from sentence_transformers import SentenceTransformer, util
import os
import psycopg2
from dotenv import load_dotenv

load_dotenv()

# --- Configuration ---
os.environ['SENTENCE_TRANSFORMERS_HOME'] = './.cache'

print("Loading sentence-transformer model...")
MODEL_NAME = 'all-MiniLM-L6-v2'
model = SentenceTransformer(MODEL_NAME)
print("Model loaded successfully.")

DATABASE_URL = os.getenv('DATABASE_URL')
conn = None
try:
    print("Connecting to the database for RAG...")
    conn = psycopg2.connect(DATABASE_URL)
    print("Database connection successful.")
except psycopg2.OperationalError as e:
    print(f"FATAL: Could not connect to the database: {e}")
    conn = None

knowledge_cache = []

# --- Pydantic Models ---
class DonorScoreRequest(BaseModel):
    donor_id: str
    last_donation_date: Optional[str] = None
    streak_count: int = 0
    notifications_received: int = 0
    donations_confirmed: int = 0

class DonorScoreResponse(BaseModel):
    donor_id: str
    availability_score: float
    reliability_score: float
    final_score: float

# âœ… NEW: Models for the RAG endpoint
class RagRequest(BaseModel):
    query: str

class RagResponse(BaseModel):
    answer: str
    source_found: bool

# --- FastAPI App ---
app = FastAPI(title="BloodBridge AI Engine (Scoring & RAG)")

# --- Helper Functions ---
def calculate_availability_score(last_donation_date: Optional[str]) -> float:
    if not last_donation_date:
        return 100.0
    try:
        last_date = datetime.fromisoformat(last_donation_date.replace('Z', '+00:00'))
        days_since = (datetime.now(last_date.tzinfo) - last_date).days
        if days_since >= 90:
            return 100.0
        if days_since < 56:
            return 0.0
        return round(((days_since - 56) / (90 - 56)) * 100, 2)
    except (ValueError, TypeError):
        return 100.0

def calculate_reliability_score(streak: int, notifications: int, confirmations: int) -> float:
    streak_score = min(streak * 10, 40)
    if notifications == 0:
        response_score = 40.0
    else:
        response_rate = confirmations / notifications
        response_score = response_rate * 60
    return min(streak_score + response_score, 100.0)

# âœ… NEW: Function to load and vectorize the knowledge base
def load_knowledge_base():
    global knowledge_cache
    if not conn:
        print("WARNING: Database connection not available. Knowledge base will be empty.")
        return

    print("Loading and vectorizing knowledge base from database...")
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT id, content FROM knowledge_base;")
            rows = cur.fetchall()
            contents = [row[1] for row in rows]
            embeddings = model.encode(contents, convert_to_tensor=True)
            knowledge_cache = [
                {'id': rows[i][0], 'content': contents[i], 'embedding': embeddings[i]}
                for i in range(len(rows))
            ]
            print(f"Loaded and vectorized {len(knowledge_cache)} documents into memory.")
    except Exception as e:
        print(f"Error loading knowledge base: {e}")
        knowledge_cache = []

# âœ… NEW: FastAPI startup event to load the data
@app.on_event("startup")
async def startup_event():
    load_knowledge_base()

# --- API Endpoints ---
@app.get("/health", summary="Health Check")
async def health_check():
    return {"status": "healthy", "knowledge_base_items": len(knowledge_cache)}

@app.post("/score-donor", response_model=DonorScoreResponse, summary="Scores a single donor")
async def score_donor(request: DonorScoreRequest):
    availability = calculate_availability_score(request.last_donation_date)
    reliability = calculate_reliability_score(
        request.streak_count, request.notifications_received, request.donations_confirmed
    )
    final_score = (availability * 0.6) + (reliability * 0.4)
    if availability == 0:
        final_score = 0

    return DonorScoreResponse(
        donor_id=request.donor_id,
        availability_score=availability,
        reliability_score=reliability,
        final_score=round(final_score, 2)
    )

# âœ… NEW: The fully implemented RAG endpoint
@app.post("/generate-faq-answer", response_model=RagResponse, summary="Answers a question using RAG")
async def generate_faq_answer(request: RagRequest):
    if not knowledge_cache:
        raise HTTPException(status_code=503, detail="Knowledge base is not loaded.")

    query_embedding = model.encode(request.query, convert_to_tensor=True)

    best_match = None
    highest_similarity = -1.0

    for doc in knowledge_cache:
        similarity = util.pytorch_cos_sim(query_embedding, doc['embedding'])[0][0].item()
        if similarity > highest_similarity:
            highest_similarity = similarity
            best_match = doc

    SIMILARITY_THRESHOLD = 0.5
    if best_match and highest_similarity > SIMILARITY_THRESHOLD:
        answer = best_match['content'].split('A: ')[-1]
        return RagResponse(answer=answer, source_found=True)
    else:
        default_answer = (
            "Thank you for your question. I'm not sure about that. "
            "An NGO volunteer will get back to you shortly."
        )
        return RagResponse(answer=default_answer, source_found=False)

```

`ml_services/requirements.txt`

```
# ml_services/requirements.txt
fastapi==0.111.0
uvicorn[standard]==0.29.0
pydantic==2.7.1
sentence-transformers==2.7.0
scikit-learn==1.3.0
psycopg2-binary==2.9.9
torch==2.3.1
numpy==1.26.4
python-dotenv

```

`testcases.txt`

```
--> Scenario 1: Donor Registration & Feature Test

        I want to be a blood donor
        Register: Test Donor, Hyderabad, B+
        my status
        leaderboard
        pause my notifications for 2 weeks


--> Scenario 2: Full Emergency & Confirmation Flow

        Emergency!! We need B+ blood urgently at Apollo Hospital, Hyderabad for a patient named Priya.


--> Scenario 3: FAQ and Admin Escalation Test   

        How often can I donate blood?
        I had a bad reaction and a problem last time I donateds

        

## Test Suite 1: AI-Powered Message Routing & User Onboarding 


REG-01: Happy Path: New Donor Registration (Interactive) 


REG-02: Happy Path: New Donor Registration (One-Shot) 


REG-03: Edge Case: Re-registration Attempt 


REG-04: Edge Case: Patient Onboarding 


REG-05: Failure Case: Invalid Blood Group 

## Test Suite 2: Emergency Blood Request System 


EMG-01: Happy Path: Request, Accept & Confirm 


EMG-02: Decline & Rollover Path 


EMG-03: Failure Case: Invalid Short Code 


EMG-04: Failure Case: Invalid OTP 

## Test Suite 3: Blood Bridge Coordination 


BRG-01: Verify Bridge Priority in Emergencies 


BRG-02: Join a Bridge via Chat 


BRG-03: Attempt to Re-join a Bridge 

## Test Suite 4: Donor Engagement & Preferences 



ENG-01: Personalized Inactivity Nudge 


ENG-02: Leaderboard Broadcast 


ENG-03: Snooze Notifications 


PREF-01: Snooze Notifications (Happy Path) 


PREF-02: Verify Snooze is Respected 


PREF-03: Do Not Disturb (DND) / Unsubscribe 


PREF-04: Verify DND is Respected 


PREF-05: Re-subscribe / Re-register 

## Test Suite 5: Automated FAQ & Safety Handling 


FAQ-01: FAQ with Live Data 


FAQ-02: Sensitive Keyword Escalation 

```

